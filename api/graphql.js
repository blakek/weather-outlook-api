import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = createRequire(import.meta.url);

// node_modules/graphql/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.versionInfo = exports.version = undefined;
  var version = "16.8.1";
  exports.version = version;
  var versionInfo = Object.freeze({
    major: 16,
    minor: 8,
    patch: 1,
    preReleaseTag: null
  });
  exports.versionInfo = versionInfo;
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS((exports) => {
  var devAssert = function(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.devAssert = devAssert;
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS((exports) => {
  var isPromise = function(value) {
    return typeof (value === null || value === undefined ? undefined : value.then) === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isPromise = isPromise;
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS((exports) => {
  var isObjectLike = function(value) {
    return typeof value == "object" && value !== null;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isObjectLike = isObjectLike;
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS((exports) => {
  var invariant = function(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message != null ? message : "Unexpected invariant triggered.");
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.invariant = invariant;
});

// node_modules/graphql/language/location.js
var require_location = __commonJS((exports) => {
  var getLocation = function(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)) {
      typeof match.index === "number" || (0, _invariant.invariant)(false);
      if (match.index >= position) {
        break;
      }
      lastLineStart = match.index + match[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLocation = getLocation;
  var _invariant = require_invariant();
  var LineRegExp = /\r\n|[\n\r]/g;
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS((exports) => {
  var printLocation = function(location) {
    return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
  };
  var printSourceLocation = function(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0;i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  };
  var printPrefixedLines = function(lines) {
    const existingLines = lines.filter(([_, line]) => line !== undefined);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printLocation = printLocation;
  exports.printSourceLocation = printSourceLocation;
  var _location = require_location();
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS((exports) => {
  var toNormalizedOptions = function(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  };
  var undefinedIfEmpty = function(array) {
    return array === undefined || array.length === 0 ? undefined : array;
  };
  var printError = function(error) {
    return error.toString();
  };
  var formatError = function(error) {
    return error.toJSON();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLError = undefined;
  exports.formatError = formatError;
  exports.printError = printError;
  var _isObjectLike = require_isObjectLike();
  var _location = require_location();
  var _printLocation = require_printLocation();

  class GraphQLError extends Error {
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path !== null && path !== undefined ? path : undefined;
      this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
      this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
      const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
      this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
      this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => (0, _location.getLocation)(loc.source, loc.start));
      const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
      this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== undefined && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output = this.message;
      if (this.nodes) {
        for (const node of this.nodes) {
          if (node.loc) {
            output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
        }
      }
      return output;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  }
  exports.GraphQLError = GraphQLError;
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS((exports) => {
  var syntaxError = function(source, position, description) {
    return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.syntaxError = syntaxError;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS((exports) => {
  var isNode = function(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = undefined;
  exports.isNode = isNode;

  class Location {
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  }
  exports.Location = Location;

  class Token {
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  }
  exports.Token = Token;
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  exports.QueryDocumentKeys = QueryDocumentKeys;
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  var OperationTypeNode;
  exports.OperationTypeNode = OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DirectiveLocation = undefined;
  var DirectiveLocation;
  exports.DirectiveLocation = DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Kind = undefined;
  var Kind;
  exports.Kind = Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (exports.Kind = Kind = {}));
});

// node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS((exports) => {
  var isWhiteSpace = function(code) {
    return code === 9 || code === 32;
  };
  var isDigit = function(code) {
    return code >= 48 && code <= 57;
  };
  var isLetter = function(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
  };
  var isNameStart = function(code) {
    return isLetter(code) || code === 95;
  };
  var isNameContinue = function(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDigit = isDigit;
  exports.isLetter = isLetter;
  exports.isNameContinue = isNameContinue;
  exports.isNameStart = isNameStart;
  exports.isWhiteSpace = isWhiteSpace;
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS((exports) => {
  var dedentBlockStringLines = function(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0;i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent = leadingWhitespace(line);
      if (indent === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent < commonIndent) {
        commonIndent = indent;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
  };
  var leadingWhitespace = function(str) {
    let i = 0;
    while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  };
  var isPrintableAsBlockString = function(value) {
    if (value === "") {
      return true;
    }
    let isEmptyLine = true;
    let hasIndent = false;
    let hasCommonIndent = true;
    let seenNonEmptyLine = false;
    for (let i = 0;i < value.length; ++i) {
      switch (value.codePointAt(i)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return false;
        case 13:
          return false;
        case 10:
          if (isEmptyLine && !seenNonEmptyLine) {
            return false;
          }
          seenNonEmptyLine = true;
          isEmptyLine = true;
          hasIndent = false;
          break;
        case 9:
        case 32:
          hasIndent || (hasIndent = isEmptyLine);
          break;
        default:
          hasCommonIndent && (hasCommonIndent = hasIndent);
          isEmptyLine = false;
      }
    }
    if (isEmptyLine) {
      return false;
    }
    if (hasCommonIndent && seenNonEmptyLine) {
      return false;
    }
    return true;
  };
  var printBlockString = function(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += "\n";
    }
    return '"""' + result + '"""';
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.dedentBlockStringLines = dedentBlockStringLines;
  exports.isPrintableAsBlockString = isPrintableAsBlockString;
  exports.printBlockString = printBlockString;
  var _characterClasses = require_characterClasses();
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenKind = undefined;
  var TokenKind;
  exports.TokenKind = TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (exports.TokenKind = TokenKind = {}));
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS((exports) => {
  var isPunctuatorTokenKind = function(kind) {
    return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
  };
  var isUnicodeScalarValue = function(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  };
  var isSupplementaryCodePoint = function(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  };
  var isLeadingSurrogate = function(code) {
    return code >= 55296 && code <= 56319;
  };
  var isTrailingSurrogate = function(code) {
    return code >= 56320 && code <= 57343;
  };
  var printCodePointAt = function(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === undefined) {
      return _tokenKind.TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? "'\"'" : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  };
  var createToken = function(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new _ast.Token(kind, start, end, line, col, value);
  };
  var readNextToken = function(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if ((0, _characterClasses.isDigit)(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if ((0, _characterClasses.isNameStart)(code)) {
        return readName(lexer, position);
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
  };
  var readComment = function(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));
  };
  var readNumber = function(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if ((0, _characterClasses.isDigit)(code)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));
  };
  var readDigits = function(lexer, start, firstCode) {
    if (!(0, _characterClasses.isDigit)(firstCode)) {
      throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
    }
    const body = lexer.source.body;
    let position = start + 1;
    while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  };
  var readString = function(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape2.value;
        position += escape2.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
  };
  var readEscapedUnicodeVariableWidth = function(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
  };
  var readEscapedUnicodeFixedWidth = function(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
  };
  var read16BitHexCode = function(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  };
  var readHexDigit = function(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  };
  var readEscapedCharacter = function(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: `
`,
          size: 2
        };
      case 114:
        return {
          value: `\r`,
          size: 2
        };
      case 116:
        return {
          value: "\t",
          size: 2
        };
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
  };
  var readBlockString = function(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join("\n"));
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
  };
  var readName = function(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if ((0, _characterClasses.isNameContinue)(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Lexer = undefined;
  exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
  var _syntaxError = require_syntaxError();
  var _ast = require_ast();
  var _blockString = require_blockString();
  var _characterClasses = require_characterClasses();
  var _tokenKind = require_tokenKind();

  class Lexer {
    constructor(source) {
      const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    lookahead() {
      let token = this.token;
      if (token.kind !== _tokenKind.TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === _tokenKind.TokenKind.COMMENT);
      }
      return token;
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS((exports) => {
  var inspect = function(value) {
    return formatValue(value, []);
  };
  var formatValue = function(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  };
  var formatObjectValue = function(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  };
  var isJSONable = function(value) {
    return typeof value.toJSON === "function";
  };
  var formatObject = function(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
  };
  var formatArray = function(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0;i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  };
  var getObjectTag = function(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.inspect = inspect;
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.instanceOf = undefined;
  var _inspect = require_inspect();
  var instanceOf = globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
      if (className === valueClassName) {
        const stringifiedValue = (0, _inspect.inspect)(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  };
  exports.instanceOf = instanceOf;
});

// node_modules/graphql/language/source.js
var require_source = __commonJS((exports) => {
  var isSource = function(source) {
    return (0, _instanceOf.instanceOf)(source, Source);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Source = undefined;
  exports.isSource = isSource;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();

  class Source {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
      this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  }
  exports.Source = Source;
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS((exports) => {
  var parse = function(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
  };
  var parseValue = function(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseValueLiteral(false);
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
  };
  var parseConstValue = function(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseConstValueLiteral();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
  };
  var parseType = function(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const type = parser.parseTypeReference();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return type;
  };
  var getTokenDesc = function(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  };
  var getTokenKindDesc = function(kind) {
    return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Parser = undefined;
  exports.parse = parse;
  exports.parseConstValue = parseConstValue;
  exports.parseType = parseType;
  exports.parseValue = parseValue;
  var _syntaxError = require_syntaxError();
  var _ast = require_ast();
  var _directiveLocation = require_directiveLocation();
  var _kinds = require_kinds();
  var _lexer = require_lexer();
  var _source = require_source();
  var _tokenKind = require_tokenKind();

  class Parser {
    constructor(source, options = {}) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      this._lexer = new _lexer.Lexer(sourceObj);
      this._options = options;
      this._tokenCounter = 0;
    }
    parseName() {
      const token = this.expectToken(_tokenKind.TokenKind.NAME);
      return this.node(token, {
        kind: _kinds.Kind.NAME,
        value: token.value
      });
    }
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.DOCUMENT,
        definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
      });
    }
    parseDefinition() {
      if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation: _ast.OperationTypeNode.QUERY,
          name: undefined,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(_tokenKind.TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: _kinds.Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseOperationType() {
      const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return _ast.OperationTypeNode.QUERY;
        case "mutation":
          return _ast.OperationTypeNode.MUTATION;
        case "subscription":
          return _ast.OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    parseVariableDefinitions() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
    }
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
        directives: this.parseConstDirectives()
      });
    }
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.DOLLAR);
      return this.node(start, {
        kind: _kinds.Kind.VARIABLE,
        name: this.parseName()
      });
    }
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.SELECTION_SET,
        selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
      });
    }
    parseSelection() {
      return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: _kinds.Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
      });
    }
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
    }
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return this.node(start, {
        kind: _kinds.Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: _kinds.Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentDefinition() {
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: _kinds.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case _tokenKind.TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case _tokenKind.TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case _tokenKind.TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.INT,
            value: token.value
          });
        case _tokenKind.TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.FLOAT,
            value: token.value
          });
        case _tokenKind.TokenKind.STRING:
        case _tokenKind.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case _tokenKind.TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: _kinds.Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: _kinds.Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: _kinds.Kind.NULL
              });
            default:
              return this.node(token, {
                kind: _kinds.Kind.ENUM,
                value: token.value
              });
          }
        case _tokenKind.TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(_tokenKind.TokenKind.DOLLAR);
            if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: _kinds.Kind.STRING,
        value: token.value,
        block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
      });
    }
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.LIST,
        values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
      });
    }
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.OBJECT,
        fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
      });
    }
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(_tokenKind.TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.AT);
      return this.node(start, {
        kind: _kinds.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    parseTypeReference() {
      const start = this._lexer.token;
      let type;
      if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(_tokenKind.TokenKind.BRACKET_R);
        type = this.node(start, {
          kind: _kinds.Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type = this.parseNamedType();
      }
      if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
        return this.node(start, {
          kind: _kinds.Kind.NON_NULL_TYPE,
          type
        });
      }
      return type;
    }
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    peekDescription() {
      return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
    }
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      return this.node(start, {
        kind: _kinds.Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type = this.parseNamedType();
      return this.node(start, {
        kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type
      });
    }
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
    }
    parseFieldsDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type,
        directives
      });
    }
    parseArgumentDefs() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
    }
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type,
        defaultValue,
        directives
      });
    }
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: _kinds.Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types
      });
    }
    parseUnionMemberTypes() {
      return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
    }
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    parseEnumValuesDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
      }
      return this.parseName();
    }
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    parseInputFieldsDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
    }
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types
      });
    }
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(_tokenKind.TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: _kinds.Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    parseDirectiveLocations() {
      return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
    }
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    node(startToken, node) {
      if (this._options.noLocation !== true) {
        node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
      }
      return node;
    }
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return token;
      }
      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
    }
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
      }
    }
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    unexpected(atToken) {
      const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
      return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
    }
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (maxTokens !== undefined && token.kind !== _tokenKind.TokenKind.EOF) {
        ++this._tokenCounter;
        if (this._tokenCounter > maxTokens) {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
        }
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS((exports) => {
  var didYouMean = function(firstArg, secondArg) {
    const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
    let message = " Did you mean ";
    if (subMessage) {
      message += subMessage + " ";
    }
    const suggestions = suggestionsArg.map((x) => `"${x}"`);
    switch (suggestions.length) {
      case 0:
        return "";
      case 1:
        return message + suggestions[0] + "?";
      case 2:
        return message + suggestions[0] + " or " + suggestions[1] + "?";
    }
    const selected = suggestions.slice(0, MAX_SUGGESTIONS);
    const lastItem = selected.pop();
    return message + selected.join(", ") + ", or " + lastItem + "?";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.didYouMean = didYouMean;
  var MAX_SUGGESTIONS = 5;
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS((exports) => {
  var identityFunc = function(x) {
    return x;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.identityFunc = identityFunc;
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS((exports) => {
  var keyMap = function(list, keyFn) {
    const result = Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = item;
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.keyMap = keyMap;
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS((exports) => {
  var keyValMap = function(list, keyFn, valFn) {
    const result = Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = valFn(item);
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.keyValMap = keyValMap;
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS((exports) => {
  var mapValue = function(map, fn) {
    const result = Object.create(null);
    for (const key of Object.keys(map)) {
      result[key] = fn(map[key], key);
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapValue = mapValue;
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS((exports) => {
  var naturalCompare = function(aStr, bStr) {
    let aIndex = 0;
    let bIndex = 0;
    while (aIndex < aStr.length && bIndex < bStr.length) {
      let aChar = aStr.charCodeAt(aIndex);
      let bChar = bStr.charCodeAt(bIndex);
      if (isDigit(aChar) && isDigit(bChar)) {
        let aNum = 0;
        do {
          ++aIndex;
          aNum = aNum * 10 + aChar - DIGIT_0;
          aChar = aStr.charCodeAt(aIndex);
        } while (isDigit(aChar) && aNum > 0);
        let bNum = 0;
        do {
          ++bIndex;
          bNum = bNum * 10 + bChar - DIGIT_0;
          bChar = bStr.charCodeAt(bIndex);
        } while (isDigit(bChar) && bNum > 0);
        if (aNum < bNum) {
          return -1;
        }
        if (aNum > bNum) {
          return 1;
        }
      } else {
        if (aChar < bChar) {
          return -1;
        }
        if (aChar > bChar) {
          return 1;
        }
        ++aIndex;
        ++bIndex;
      }
    }
    return aStr.length - bStr.length;
  };
  var isDigit = function(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.naturalCompare = naturalCompare;
  var DIGIT_0 = 48;
  var DIGIT_9 = 57;
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS((exports) => {
  var suggestionList = function(input, options) {
    const optionsByDistance = Object.create(null);
    const lexicalDistance = new LexicalDistance(input);
    const threshold = Math.floor(input.length * 0.4) + 1;
    for (const option of options) {
      const distance = lexicalDistance.measure(option, threshold);
      if (distance !== undefined) {
        optionsByDistance[option] = distance;
      }
    }
    return Object.keys(optionsByDistance).sort((a, b) => {
      const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
      return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
    });
  };
  var stringToArray = function(str) {
    const strLength = str.length;
    const array = new Array(strLength);
    for (let i = 0;i < strLength; ++i) {
      array[i] = str.charCodeAt(i);
    }
    return array;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.suggestionList = suggestionList;
  var _naturalCompare = require_naturalCompare();

  class LexicalDistance {
    constructor(input) {
      this._input = input;
      this._inputLowerCase = input.toLowerCase();
      this._inputArray = stringToArray(this._inputLowerCase);
      this._rows = [
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0)
      ];
    }
    measure(option, threshold) {
      if (this._input === option) {
        return 0;
      }
      const optionLowerCase = option.toLowerCase();
      if (this._inputLowerCase === optionLowerCase) {
        return 1;
      }
      let a = stringToArray(optionLowerCase);
      let b = this._inputArray;
      if (a.length < b.length) {
        const tmp = a;
        a = b;
        b = tmp;
      }
      const aLength = a.length;
      const bLength = b.length;
      if (aLength - bLength > threshold) {
        return;
      }
      const rows = this._rows;
      for (let j = 0;j <= bLength; j++) {
        rows[0][j] = j;
      }
      for (let i = 1;i <= aLength; i++) {
        const upRow = rows[(i - 1) % 3];
        const currentRow = rows[i % 3];
        let smallestCell = currentRow[0] = i;
        for (let j = 1;j <= bLength; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
            currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
          }
          if (currentCell < smallestCell) {
            smallestCell = currentCell;
          }
          currentRow[j] = currentCell;
        }
        if (smallestCell > threshold) {
          return;
        }
      }
      const distance = rows[aLength % 3][bLength];
      return distance <= threshold ? distance : undefined;
    }
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS((exports) => {
  var toObjMap = function(obj) {
    if (obj == null) {
      return Object.create(null);
    }
    if (Object.getPrototypeOf(obj) === null) {
      return obj;
    }
    const map = Object.create(null);
    for (const [key, value] of Object.entries(obj)) {
      map[key] = value;
    }
    return map;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toObjMap = toObjMap;
});

// node_modules/graphql/language/printString.js
var require_printString = __commonJS((exports) => {
  var printString = function(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  };
  var escapedReplacer = function(str) {
    return escapeSequences[str.charCodeAt(0)];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printString = printString;
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS((exports) => {
  var visit = function(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
    const enterLeaveMap = new Map;
    for (const kind of Object.values(_kinds.Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = undefined;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let edits = [];
    let node = root;
    let key = undefined;
    let parent = undefined;
    const path = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? undefined : path[path.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node.splice(arrayKey, 1);
                editOffset++;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys[index];
        node = parent[key];
        if (node === null || node === undefined) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);
          if (!isLeaving) {
            if ((0, _ast.isNode)(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === undefined && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== undefined);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  };
  var visitInParallel = function(visitors) {
    const skipping = new Array(visitors.length).fill(null);
    const mergedVisitor = Object.create(null);
    for (const kind of Object.values(_kinds.Kind)) {
      let hasVisitor = false;
      const enterList = new Array(visitors.length).fill(undefined);
      const leaveList = new Array(visitors.length).fill(undefined);
      for (let i = 0;i < visitors.length; ++i) {
        const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
        hasVisitor || (hasVisitor = enter != null || leave != null);
        enterList[i] = enter;
        leaveList[i] = leave;
      }
      if (!hasVisitor) {
        continue;
      }
      const mergedEnterLeave = {
        enter(...args) {
          const node = args[0];
          for (let i = 0;i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _enterList$i;
              const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
              if (result === false) {
                skipping[i] = node;
              } else if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined) {
                return result;
              }
            }
          }
        },
        leave(...args) {
          const node = args[0];
          for (let i = 0;i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _leaveList$i;
              const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
              if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined && result !== false) {
                return result;
              }
            } else if (skipping[i] === node) {
              skipping[i] = null;
            }
          }
        }
      };
      mergedVisitor[kind] = mergedEnterLeave;
    }
    return mergedVisitor;
  };
  var getEnterLeaveForKind = function(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: undefined
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  };
  var getVisitFn = function(visitor, kind, isLeaving) {
    const { enter, leave } = getEnterLeaveForKind(visitor, kind);
    return isLeaving ? leave : enter;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BREAK = undefined;
  exports.getEnterLeaveForKind = getEnterLeaveForKind;
  exports.getVisitFn = getVisitFn;
  exports.visit = visit;
  exports.visitInParallel = visitInParallel;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _ast = require_ast();
  var _kinds = require_kinds();
  var BREAK = Object.freeze({});
  exports.BREAK = BREAK;
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS((exports) => {
  var print = function(ast) {
    return (0, _visitor.visit)(ast, printDocASTReducer);
  };
  var join = function(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
  };
  var block = function(array) {
    return wrap("{\n", indent(join(array, "\n")), "\n}");
  };
  var wrap = function(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  };
  var indent = function(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
  };
  var hasMultilineItems = function(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.print = print;
  var _blockString = require_blockString();
  var _printString = require_printString();
  var _visitor = require_visitor();
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node) => node.value
    },
    Variable: {
      leave: (node) => "$" + node.name
    },
    Document: {
      leave: (node) => join(node.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node) {
        const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        const prefix = join([
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ], " ");
        return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name;
        let argsLine = prefix + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join([
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ], " ")
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
    },
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type }) => "[" + type + "]"
    },
    NonNullType: {
      leave: ({ type }) => type + "!"
    },
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type }) => operation + ": " + type
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join([
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ], " ")
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS((exports) => {
  var valueFromASTUntyped = function(valueNode, variables) {
    switch (valueNode.kind) {
      case _kinds.Kind.NULL:
        return null;
      case _kinds.Kind.INT:
        return parseInt(valueNode.value, 10);
      case _kinds.Kind.FLOAT:
        return parseFloat(valueNode.value);
      case _kinds.Kind.STRING:
      case _kinds.Kind.ENUM:
      case _kinds.Kind.BOOLEAN:
        return valueNode.value;
      case _kinds.Kind.LIST:
        return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
      case _kinds.Kind.OBJECT:
        return (0, _keyValMap.keyValMap)(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
      case _kinds.Kind.VARIABLE:
        return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromASTUntyped = valueFromASTUntyped;
  var _keyValMap = require_keyValMap();
  var _kinds = require_kinds();
});

// node_modules/graphql/type/assertName.js
var require_assertName = __commonJS((exports) => {
  var assertName = function(name) {
    name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.length === 0) {
      throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
    }
    for (let i = 1;i < name.length; ++i) {
      if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
        throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
      }
    }
    if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
      throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
    }
    return name;
  };
  var assertEnumValueName = function(name) {
    if (name === "true" || name === "false" || name === "null") {
      throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
    }
    return assertName(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertEnumValueName = assertEnumValueName;
  exports.assertName = assertName;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _characterClasses = require_characterClasses();
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS((exports) => {
  var isType = function(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
  };
  var assertType = function(type) {
    if (!isType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);
    }
    return type;
  };
  var isScalarType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
  };
  var assertScalarType = function(type) {
    if (!isScalarType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);
    }
    return type;
  };
  var isObjectType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
  };
  var assertObjectType = function(type) {
    if (!isObjectType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);
    }
    return type;
  };
  var isInterfaceType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
  };
  var assertInterfaceType = function(type) {
    if (!isInterfaceType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);
    }
    return type;
  };
  var isUnionType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
  };
  var assertUnionType = function(type) {
    if (!isUnionType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);
    }
    return type;
  };
  var isEnumType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
  };
  var assertEnumType = function(type) {
    if (!isEnumType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);
    }
    return type;
  };
  var isInputObjectType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
  };
  var assertInputObjectType = function(type) {
    if (!isInputObjectType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);
    }
    return type;
  };
  var isListType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLList);
  };
  var assertListType = function(type) {
    if (!isListType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);
    }
    return type;
  };
  var isNonNullType = function(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
  };
  var assertNonNullType = function(type) {
    if (!isNonNullType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);
    }
    return type;
  };
  var isInputType = function(type) {
    return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
  };
  var assertInputType = function(type) {
    if (!isInputType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);
    }
    return type;
  };
  var isOutputType = function(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
  };
  var assertOutputType = function(type) {
    if (!isOutputType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);
    }
    return type;
  };
  var isLeafType = function(type) {
    return isScalarType(type) || isEnumType(type);
  };
  var assertLeafType = function(type) {
    if (!isLeafType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);
    }
    return type;
  };
  var isCompositeType = function(type) {
    return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
  };
  var assertCompositeType = function(type) {
    if (!isCompositeType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);
    }
    return type;
  };
  var isAbstractType = function(type) {
    return isInterfaceType(type) || isUnionType(type);
  };
  var assertAbstractType = function(type) {
    if (!isAbstractType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);
    }
    return type;
  };
  var isWrappingType = function(type) {
    return isListType(type) || isNonNullType(type);
  };
  var assertWrappingType = function(type) {
    if (!isWrappingType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);
    }
    return type;
  };
  var isNullableType = function(type) {
    return isType(type) && !isNonNullType(type);
  };
  var assertNullableType = function(type) {
    if (!isNullableType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);
    }
    return type;
  };
  var getNullableType = function(type) {
    if (type) {
      return isNonNullType(type) ? type.ofType : type;
    }
  };
  var isNamedType = function(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
  };
  var assertNamedType = function(type) {
    if (!isNamedType(type)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);
    }
    return type;
  };
  var getNamedType = function(type) {
    if (type) {
      let unwrappedType = type;
      while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
      }
      return unwrappedType;
    }
  };
  var resolveReadonlyArrayThunk = function(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  };
  var resolveObjMapThunk = function(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  };
  var defineInterfaces = function(config) {
    var _config$interfaces;
    const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
    Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
    return interfaces;
  };
  var defineFieldMap = function(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
      var _fieldConfig$args;
      isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);
      fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
      const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
      isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
      return {
        name: (0, _assertName.assertName)(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        args: defineArguments(argsConfig),
        resolve: fieldConfig.resolve,
        subscribe: fieldConfig.subscribe,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  };
  var defineArguments = function(config) {
    return Object.entries(config).map(([argName, argConfig]) => ({
      name: (0, _assertName.assertName)(argName),
      description: argConfig.description,
      type: argConfig.type,
      defaultValue: argConfig.defaultValue,
      deprecationReason: argConfig.deprecationReason,
      extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
      astNode: argConfig.astNode
    }));
  };
  var isPlainObj = function(obj) {
    return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
  };
  var fieldsToFieldsConfig = function(fields) {
    return (0, _mapValue.mapValue)(fields, (field) => ({
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
  };
  var argsToArgsConfig = function(args) {
    return (0, _keyValMap.keyValMap)(args, (arg) => arg.name, (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    }));
  };
  var isRequiredArgument = function(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === undefined;
  };
  var defineTypes = function(config) {
    const types = resolveReadonlyArrayThunk(config.types);
    Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
    return types;
  };
  var didYouMeanEnumValue = function(enumType, unknownValueStr) {
    const allNames = enumType.getValues().map((value) => value.name);
    const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
    return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
  };
  var defineEnumValues = function(typeName, valueMap) {
    isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
    return Object.entries(valueMap).map(([valueName, valueConfig]) => {
      isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
      return {
        name: (0, _assertName.assertEnumValueName)(valueName),
        description: valueConfig.description,
        value: valueConfig.value !== undefined ? valueConfig.value : valueName,
        deprecationReason: valueConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
        astNode: valueConfig.astNode
      };
    });
  };
  var defineInputFieldMap = function(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
      !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
      return {
        name: (0, _assertName.assertName)(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        defaultValue: fieldConfig.defaultValue,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  };
  var isRequiredInputField = function(field) {
    return isNonNullType(field.type) && field.defaultValue === undefined;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = undefined;
  exports.argsToArgsConfig = argsToArgsConfig;
  exports.assertAbstractType = assertAbstractType;
  exports.assertCompositeType = assertCompositeType;
  exports.assertEnumType = assertEnumType;
  exports.assertInputObjectType = assertInputObjectType;
  exports.assertInputType = assertInputType;
  exports.assertInterfaceType = assertInterfaceType;
  exports.assertLeafType = assertLeafType;
  exports.assertListType = assertListType;
  exports.assertNamedType = assertNamedType;
  exports.assertNonNullType = assertNonNullType;
  exports.assertNullableType = assertNullableType;
  exports.assertObjectType = assertObjectType;
  exports.assertOutputType = assertOutputType;
  exports.assertScalarType = assertScalarType;
  exports.assertType = assertType;
  exports.assertUnionType = assertUnionType;
  exports.assertWrappingType = assertWrappingType;
  exports.defineArguments = defineArguments;
  exports.getNamedType = getNamedType;
  exports.getNullableType = getNullableType;
  exports.isAbstractType = isAbstractType;
  exports.isCompositeType = isCompositeType;
  exports.isEnumType = isEnumType;
  exports.isInputObjectType = isInputObjectType;
  exports.isInputType = isInputType;
  exports.isInterfaceType = isInterfaceType;
  exports.isLeafType = isLeafType;
  exports.isListType = isListType;
  exports.isNamedType = isNamedType;
  exports.isNonNullType = isNonNullType;
  exports.isNullableType = isNullableType;
  exports.isObjectType = isObjectType;
  exports.isOutputType = isOutputType;
  exports.isRequiredArgument = isRequiredArgument;
  exports.isRequiredInputField = isRequiredInputField;
  exports.isScalarType = isScalarType;
  exports.isType = isType;
  exports.isUnionType = isUnionType;
  exports.isWrappingType = isWrappingType;
  exports.resolveObjMapThunk = resolveObjMapThunk;
  exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
  var _devAssert = require_devAssert();
  var _didYouMean = require_didYouMean();
  var _identityFunc = require_identityFunc();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _keyMap = require_keyMap();
  var _keyValMap = require_keyValMap();
  var _mapValue = require_mapValue();
  var _suggestionList = require_suggestionList();
  var _toObjMap = require_toObjMap();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  var _assertName = require_assertName();

  class GraphQLList {
    constructor(ofType) {
      isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLList = GraphQLList;

  class GraphQLNonNull {
    constructor(ofType) {
      isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLNonNull = GraphQLNonNull;

  class GraphQLScalarType {
    constructor(config) {
      var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
      const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : _identityFunc.identityFunc;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.specifiedByURL = config.specifiedByURL;
      this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : _identityFunc.identityFunc;
      this.parseValue = parseValue;
      this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
      config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);
      config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
      if (config.parseLiteral) {
        typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLScalarType = GraphQLScalarType;

  class GraphQLObjectType {
    constructor(config) {
      var _config$extensionASTN2;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.isTypeOf = config.isTypeOf;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
      this._fields = () => defineFieldMap(config);
      this._interfaces = () => defineInterfaces(config);
      config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLObjectType = GraphQLObjectType;

  class GraphQLInterfaceType {
    constructor(config) {
      var _config$extensionASTN3;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
      this._fields = defineFieldMap.bind(undefined, config);
      this._interfaces = defineInterfaces.bind(undefined, config);
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLInterfaceType = GraphQLInterfaceType;

  class GraphQLUnionType {
    constructor(config) {
      var _config$extensionASTN4;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
      this._types = defineTypes.bind(undefined, config);
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      if (typeof this._types === "function") {
        this._types = this._types();
      }
      return this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLUnionType = GraphQLUnionType;

  class GraphQLEnumType {
    constructor(config) {
      var _config$extensionASTN5;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
      this._values = defineEnumValues(this.name, config.values);
      this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
      this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      return this._values;
    }
    getValue(name) {
      return this._nameLookup[name];
    }
    serialize(outputValue) {
      const enumValue = this._valueLookup.get(outputValue);
      if (enumValue === undefined) {
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
      }
      return enumValue.name;
    }
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        const valueStr = (0, _inspect.inspect)(inputValue);
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
      }
      const enumValue = this.getValue(inputValue);
      if (enumValue == null) {
        throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
      }
      return enumValue.value;
    }
    parseLiteral(valueNode, _variables) {
      if (valueNode.kind !== _kinds.Kind.ENUM) {
        const valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
          nodes: valueNode
        });
      }
      const enumValue = this.getValue(valueNode.value);
      if (enumValue == null) {
        const valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
          nodes: valueNode
        });
      }
      return enumValue.value;
    }
    toConfig() {
      const values = (0, _keyValMap.keyValMap)(this.getValues(), (value) => value.name, (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        values,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLEnumType = GraphQLEnumType;

  class GraphQLInputObjectType {
    constructor(config) {
      var _config$extensionASTN6;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
      this._fields = defineInputFieldMap.bind(undefined, config);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    toConfig() {
      const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLInputObjectType = GraphQLInputObjectType;
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS((exports) => {
  var isEqualType = function(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    return false;
  };
  var isTypeSubTypeOf = function(schema, maybeSubType, superType) {
    if (maybeSubType === superType) {
      return true;
    }
    if ((0, _definition.isNonNullType)(superType)) {
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isNonNullType)(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    }
    if ((0, _definition.isListType)(superType)) {
      if ((0, _definition.isListType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isListType)(maybeSubType)) {
      return false;
    }
    return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
  };
  var doTypesOverlap = function(schema, typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isAbstractType)(typeA)) {
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
      }
      return schema.isSubType(typeA, typeB);
    }
    if ((0, _definition.isAbstractType)(typeB)) {
      return schema.isSubType(typeB, typeA);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.doTypesOverlap = doTypesOverlap;
  exports.isEqualType = isEqualType;
  exports.isTypeSubTypeOf = isTypeSubTypeOf;
  var _definition = require_definition();
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS((exports) => {
  var isSpecifiedScalarType = function(type) {
    return specifiedScalarTypes.some(({ name }) => type.name === name);
  };
  var serializeObject = function(outputValue) {
    if ((0, _isObjectLike.isObjectLike)(outputValue)) {
      if (typeof outputValue.valueOf === "function") {
        const valueOfResult = outputValue.valueOf();
        if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
          return valueOfResult;
        }
      }
      if (typeof outputValue.toJSON === "function") {
        return outputValue.toJSON();
      }
    }
    return outputValue;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = undefined;
  exports.isSpecifiedScalarType = isSpecifiedScalarType;
  exports.specifiedScalarTypes = undefined;
  var _inspect = require_inspect();
  var _isObjectLike = require_isObjectLike();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var GRAPHQL_MAX_INT = 2147483647;
  exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
  var GRAPHQL_MIN_INT = -2147483648;
  exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
  var GraphQLInt = new _definition.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isInteger(num)) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
      }
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      const num = parseInt(valueNode.value, 10);
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
          nodes: valueNode
        });
      }
      return num;
    }
  });
  exports.GraphQLInt = GraphQLInt;
  var GraphQLFloat = new _definition.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isFinite(num)) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
      }
      return parseFloat(valueNode.value);
    }
  });
  exports.GraphQLFloat = GraphQLFloat;
  var GraphQLString = new _definition.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (typeof coercedValue === "boolean") {
        return coercedValue ? "true" : "false";
      }
      if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
        return coercedValue.toString();
      }
      throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING) {
        throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLString = GraphQLString;
  var GraphQLBoolean = new _definition.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue;
      }
      if (Number.isFinite(coercedValue)) {
        return coercedValue !== 0;
      }
      throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "boolean") {
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLBoolean = GraphQLBoolean;
  var GraphQLID = new _definition.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (Number.isInteger(coercedValue)) {
        return String(coercedValue);
      }
      throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue === "string") {
        return inputValue;
      }
      if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
        return inputValue.toString();
      }
      throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLID = GraphQLID;
  var specifiedScalarTypes = Object.freeze([
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLID
  ]);
  exports.specifiedScalarTypes = specifiedScalarTypes;
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS((exports) => {
  var isDirective = function(directive) {
    return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
  };
  var assertDirective = function(directive) {
    if (!isDirective(directive)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
    }
    return directive;
  };
  var isSpecifiedDirective = function(directive) {
    return specifiedDirectives.some(({ name }) => name === directive.name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = undefined;
  exports.assertDirective = assertDirective;
  exports.isDirective = isDirective;
  exports.isSpecifiedDirective = isSpecifiedDirective;
  exports.specifiedDirectives = undefined;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _toObjMap = require_toObjMap();
  var _directiveLocation = require_directiveLocation();
  var _assertName = require_assertName();
  var _definition = require_definition();
  var _scalars = require_scalars();

  class GraphQLDirective {
    constructor(config) {
      var _config$isRepeatable, _config$args;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.locations = config.locations;
      this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      Array.isArray(config.locations) || (0, _devAssert.devAssert)(false, `@${config.name} locations must be an Array.`);
      const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
      (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config.name} args must be an object with argument names as keys.`);
      this.args = (0, _definition.defineArguments)(args);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, _definition.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLDirective = GraphQLDirective;
  var GraphQLIncludeDirective = new GraphQLDirective({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD,
      _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
      _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
  var GraphQLSkipDirective = new GraphQLDirective({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD,
      _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
      _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  exports.GraphQLSkipDirective = GraphQLSkipDirective;
  var DEFAULT_DEPRECATION_REASON = "No longer supported";
  exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
  var GraphQLDeprecatedDirective = new GraphQLDirective({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
      _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
      _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
      _directiveLocation.DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: _scalars.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: DEFAULT_DEPRECATION_REASON
      }
    }
  });
  exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
  var GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [_directiveLocation.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
  var specifiedDirectives = Object.freeze([
    GraphQLIncludeDirective,
    GraphQLSkipDirective,
    GraphQLDeprecatedDirective,
    GraphQLSpecifiedByDirective
  ]);
  exports.specifiedDirectives = specifiedDirectives;
});

// node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS((exports) => {
  var isIterableObject = function(maybeIterable) {
    return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIterableObject = isIterableObject;
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS((exports) => {
  var astFromValue = function(value, type) {
    if ((0, _definition.isNonNullType)(type)) {
      const astValue = astFromValue(value, type.ofType);
      if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === _kinds.Kind.NULL) {
        return null;
      }
      return astValue;
    }
    if (value === null) {
      return {
        kind: _kinds.Kind.NULL
      };
    }
    if (value === undefined) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      const itemType = type.ofType;
      if ((0, _isIterableObject.isIterableObject)(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValue(item, itemType);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return {
          kind: _kinds.Kind.LIST,
          values: valuesNodes
        };
      }
      return astFromValue(value, itemType);
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (!(0, _isObjectLike.isObjectLike)(value)) {
        return null;
      }
      const fieldNodes = [];
      for (const field of Object.values(type.getFields())) {
        const fieldValue = astFromValue(value[field.name], field.type);
        if (fieldValue) {
          fieldNodes.push({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: {
              kind: _kinds.Kind.NAME,
              value: field.name
            },
            value: fieldValue
          });
        }
      }
      return {
        kind: _kinds.Kind.OBJECT,
        fields: fieldNodes
      };
    }
    if ((0, _definition.isLeafType)(type)) {
      const serialized = type.serialize(value);
      if (serialized == null) {
        return null;
      }
      if (typeof serialized === "boolean") {
        return {
          kind: _kinds.Kind.BOOLEAN,
          value: serialized
        };
      }
      if (typeof serialized === "number" && Number.isFinite(serialized)) {
        const stringNum = String(serialized);
        return integerStringRegExp.test(stringNum) ? {
          kind: _kinds.Kind.INT,
          value: stringNum
        } : {
          kind: _kinds.Kind.FLOAT,
          value: stringNum
        };
      }
      if (typeof serialized === "string") {
        if ((0, _definition.isEnumType)(type)) {
          return {
            kind: _kinds.Kind.ENUM,
            value: serialized
          };
        }
        if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
          return {
            kind: _kinds.Kind.INT,
            value: serialized
          };
        }
        return {
          kind: _kinds.Kind.STRING,
          value: serialized
        };
      }
      throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.astFromValue = astFromValue;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _scalars = require_scalars();
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS((exports) => {
  var isIntrospectionType = function(type) {
    return introspectionTypes.some(({ name }) => type.name === name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = undefined;
  exports.isIntrospectionType = isIntrospectionType;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _directiveLocation = require_directiveLocation();
  var _printer = require_printer();
  var _astFromValue = require_astFromValue();
  var _definition = require_definition();
  var _scalars = require_scalars();
  var __Schema = new _definition.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: _scalars.GraphQLString,
        resolve: (schema) => schema.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
        resolve(schema) {
          return Object.values(schema.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (schema) => schema.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
        resolve: (schema) => schema.getDirectives()
      }
    })
  });
  exports.__Schema = __Schema;
  var __Directive = new _definition.GraphQLObjectType({
    name: "__Directive",
    description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (directive) => directive.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (directive) => directive.description
      },
      isRepeatable: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (directive) => directive.isRepeatable
      },
      locations: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
        resolve: (directive) => directive.locations
      },
      args: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      }
    })
  });
  exports.__Directive = __Directive;
  var __DirectiveLocation = new _definition.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: _directiveLocation.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: _directiveLocation.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: _directiveLocation.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: _directiveLocation.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: _directiveLocation.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: _directiveLocation.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: _directiveLocation.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: _directiveLocation.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: _directiveLocation.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  exports.__DirectiveLocation = __DirectiveLocation;
  var __Type = new _definition.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new _definition.GraphQLNonNull(__TypeKind),
        resolve(type) {
          if ((0, _definition.isScalarType)(type)) {
            return TypeKind.SCALAR;
          }
          if ((0, _definition.isObjectType)(type)) {
            return TypeKind.OBJECT;
          }
          if ((0, _definition.isInterfaceType)(type)) {
            return TypeKind.INTERFACE;
          }
          if ((0, _definition.isUnionType)(type)) {
            return TypeKind.UNION;
          }
          if ((0, _definition.isEnumType)(type)) {
            return TypeKind.ENUM;
          }
          if ((0, _definition.isInputObjectType)(type)) {
            return TypeKind.INPUT_OBJECT;
          }
          if ((0, _definition.isListType)(type)) {
            return TypeKind.LIST;
          }
          if ((0, _definition.isNonNullType)(type)) {
            return TypeKind.NON_NULL;
          }
          (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type)}".`);
        }
      },
      name: {
        type: _scalars.GraphQLString,
        resolve: (type) => ("name" in type) ? type.name : undefined
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (type) => ("description" in type) ? type.description : undefined
      },
      specifiedByURL: {
        type: _scalars.GraphQLString,
        resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
      },
      fields: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type, { includeDeprecated }) {
          if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
            const fields = Object.values(type.getFields());
            return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
        resolve(type) {
          if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
            return type.getInterfaces();
          }
        }
      },
      possibleTypes: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
        resolve(type, _args, _context, { schema }) {
          if ((0, _definition.isAbstractType)(type)) {
            return schema.getPossibleTypes(type);
          }
        }
      },
      enumValues: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type, { includeDeprecated }) {
          if ((0, _definition.isEnumType)(type)) {
            const values = type.getValues();
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type, { includeDeprecated }) {
          if ((0, _definition.isInputObjectType)(type)) {
            const values = Object.values(type.getFields());
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: __Type,
        resolve: (type) => ("ofType" in type) ? type.ofType : undefined
      }
    })
  });
  exports.__Type = __Type;
  var __Field = new _definition.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (field) => field.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (field) => field.description
      },
      args: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      },
      type: {
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (field) => field.type
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (field) => field.deprecationReason
      }
    })
  });
  exports.__Field = __Field;
  var __InputValue = new _definition.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (inputValue) => inputValue.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (inputValue) => inputValue.description
      },
      type: {
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (inputValue) => inputValue.type
      },
      defaultValue: {
        type: _scalars.GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(inputValue) {
          const { type, defaultValue } = inputValue;
          const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
          return valueAST ? (0, _printer.print)(valueAST) : null;
        }
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (obj) => obj.deprecationReason
      }
    })
  });
  exports.__InputValue = __InputValue;
  var __EnumValue = new _definition.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (enumValue) => enumValue.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (enumValue) => enumValue.description
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (enumValue) => enumValue.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (enumValue) => enumValue.deprecationReason
      }
    })
  });
  exports.__EnumValue = __EnumValue;
  var TypeKind;
  exports.TypeKind = TypeKind;
  (function(TypeKind2) {
    TypeKind2["SCALAR"] = "SCALAR";
    TypeKind2["OBJECT"] = "OBJECT";
    TypeKind2["INTERFACE"] = "INTERFACE";
    TypeKind2["UNION"] = "UNION";
    TypeKind2["ENUM"] = "ENUM";
    TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
    TypeKind2["LIST"] = "LIST";
    TypeKind2["NON_NULL"] = "NON_NULL";
  })(TypeKind || (exports.TypeKind = TypeKind = {}));
  var __TypeKind = new _definition.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: TypeKind.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: TypeKind.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: TypeKind.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: TypeKind.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: TypeKind.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: TypeKind.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: TypeKind.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: TypeKind.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  exports.__TypeKind = __TypeKind;
  var SchemaMetaFieldDef = {
    name: "__schema",
    type: new _definition.GraphQLNonNull(__Schema),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_source, _args, _context, { schema }) => schema,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
  var TypeMetaFieldDef = {
    name: "__type",
    type: __Type,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: undefined,
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        defaultValue: undefined,
        deprecationReason: undefined,
        extensions: Object.create(null),
        astNode: undefined
      }
    ],
    resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.TypeMetaFieldDef = TypeMetaFieldDef;
  var TypeNameMetaFieldDef = {
    name: "__typename",
    type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_source, _args, _context, { parentType }) => parentType.name,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
  var introspectionTypes = Object.freeze([
    __Schema,
    __Directive,
    __DirectiveLocation,
    __Type,
    __Field,
    __InputValue,
    __EnumValue,
    __TypeKind
  ]);
  exports.introspectionTypes = introspectionTypes;
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS((exports) => {
  var isSchema = function(schema) {
    return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
  };
  var assertSchema = function(schema) {
    if (!isSchema(schema)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
    }
    return schema;
  };
  var collectReferencedTypes = function(type, typeSet) {
    const namedType = (0, _definition.getNamedType)(type);
    if (!typeSet.has(namedType)) {
      typeSet.add(namedType);
      if ((0, _definition.isUnionType)(namedType)) {
        for (const memberType of namedType.getTypes()) {
          collectReferencedTypes(memberType, typeSet);
        }
      } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
        for (const interfaceType of namedType.getInterfaces()) {
          collectReferencedTypes(interfaceType, typeSet);
        }
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
          for (const arg of field.args) {
            collectReferencedTypes(arg.type, typeSet);
          }
        }
      } else if ((0, _definition.isInputObjectType)(namedType)) {
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
        }
      }
    }
    return typeSet;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLSchema = undefined;
  exports.assertSchema = assertSchema;
  exports.isSchema = isSchema;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _toObjMap = require_toObjMap();
  var _ast = require_ast();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();

  class GraphQLSchema {
    constructor(config) {
      var _config$extensionASTN, _config$directives;
      this.__validationErrors = config.assumeValid === true ? [] : undefined;
      (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
      !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);
      !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, '"directives" must be Array if provided but got: ' + `${(0, _inspect.inspect)(config.directives)}.`);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
      this._queryType = config.query;
      this._mutationType = config.mutation;
      this._subscriptionType = config.subscription;
      this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : _directives.specifiedDirectives;
      const allReferencedTypes = new Set(config.types);
      if (config.types != null) {
        for (const type of config.types) {
          allReferencedTypes.delete(type);
          collectReferencedTypes(type, allReferencedTypes);
        }
      }
      if (this._queryType != null) {
        collectReferencedTypes(this._queryType, allReferencedTypes);
      }
      if (this._mutationType != null) {
        collectReferencedTypes(this._mutationType, allReferencedTypes);
      }
      if (this._subscriptionType != null) {
        collectReferencedTypes(this._subscriptionType, allReferencedTypes);
      }
      for (const directive of this._directives) {
        if ((0, _directives.isDirective)(directive)) {
          for (const arg of directive.args) {
            collectReferencedTypes(arg.type, allReferencedTypes);
          }
        }
      }
      collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
      this._typeMap = Object.create(null);
      this._subTypeMap = Object.create(null);
      this._implementationsMap = Object.create(null);
      for (const namedType of allReferencedTypes) {
        if (namedType == null) {
          continue;
        }
        const typeName = namedType.name;
        typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
        if (this._typeMap[typeName] !== undefined) {
          throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
        }
        this._typeMap[typeName] = namedType;
        if ((0, _definition.isInterfaceType)(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if ((0, _definition.isInterfaceType)(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === undefined) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.interfaces.push(namedType);
            }
          }
        } else if ((0, _definition.isObjectType)(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if ((0, _definition.isInterfaceType)(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === undefined) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.objects.push(namedType);
            }
          }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return this.getQueryType();
        case _ast.OperationTypeNode.MUTATION:
          return this.getMutationType();
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(name) {
      return this.getTypeMap()[name];
    }
    getPossibleTypes(abstractType) {
      return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
    }
    getImplementations(interfaceType) {
      const implementations = this._implementationsMap[interfaceType.name];
      return implementations !== null && implementations !== undefined ? implementations : {
        objects: [],
        interfaces: []
      };
    }
    isSubType(abstractType, maybeSubType) {
      let map = this._subTypeMap[abstractType.name];
      if (map === undefined) {
        map = Object.create(null);
        if ((0, _definition.isUnionType)(abstractType)) {
          for (const type of abstractType.getTypes()) {
            map[type.name] = true;
          }
        } else {
          const implementations = this.getImplementations(abstractType);
          for (const type of implementations.objects) {
            map[type.name] = true;
          }
          for (const type of implementations.interfaces) {
            map[type.name] = true;
          }
        }
        this._subTypeMap[abstractType.name] = map;
      }
      return map[maybeSubType.name] !== undefined;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(name) {
      return this.getDirectives().find((directive) => directive.name === name);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== undefined
      };
    }
  }
  exports.GraphQLSchema = GraphQLSchema;
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS((exports) => {
  var validateSchema = function(schema) {
    (0, _schema.assertSchema)(schema);
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    const context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    const errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  };
  var assertValidSchema = function(schema) {
    const errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  };
  var validateRootTypes = function(context) {
    const schema = context.schema;
    const queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!(0, _definition.isObjectType)(queryType)) {
      var _getOperationTypeNode;
      context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
    }
    const mutationType = schema.getMutationType();
    if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
      var _getOperationTypeNode2;
      context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
      var _getOperationTypeNode3;
      context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
    }
  };
  var getOperationTypeNode = function(schema, operation) {
    var _flatMap$find;
    return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
      var _schemaNode$operation;
      return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
    }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
  };
  var validateDirectives = function(context) {
    for (const directive of context.schema.getDirectives()) {
      if (!(0, _directives.isDirective)(directive)) {
        context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
        continue;
      }
      validateName(context, directive);
      for (const arg of directive.args) {
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode;
          context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
          ]);
        }
      }
    }
  };
  var validateName = function(context, node) {
    if (node.name.startsWith("__")) {
      context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
    }
  };
  var validateTypes = function(context) {
    const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    const typeMap = context.schema.getTypeMap();
    for (const type of Object.values(typeMap)) {
      if (!(0, _definition.isNamedType)(type)) {
        context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);
        continue;
      }
      if (!(0, _introspection.isIntrospectionType)(type)) {
        validateName(context, type);
      }
      if ((0, _definition.isObjectType)(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if ((0, _definition.isInterfaceType)(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if ((0, _definition.isUnionType)(type)) {
        validateUnionMembers(context, type);
      } else if ((0, _definition.isEnumType)(type)) {
        validateEnumValues(context, type);
      } else if ((0, _definition.isInputObjectType)(type)) {
        validateInputFields(context, type);
        validateInputObjectCircularRefs(type);
      }
    }
  };
  var validateFields = function(context, type) {
    const fields = Object.values(type.getFields());
    if (fields.length === 0) {
      context.reportError(`Type ${type.name} must define one or more fields.`, [
        type.astNode,
        ...type.extensionASTNodes
      ]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!(0, _definition.isOutputType)(field.type)) {
        var _field$astNode;
        context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
      }
      for (const arg of field.args) {
        const argName = arg.name;
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          var _arg$astNode2;
          context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode3;
          context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
          ]);
        }
      }
    }
  };
  var validateInterfaces = function(context, type) {
    const ifaceTypeNames = Object.create(null);
    for (const iface of type.getInterfaces()) {
      if (!(0, _definition.isInterfaceType)(iface)) {
        context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, ` + `it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      if (type === iface) {
        context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      if (ifaceTypeNames[iface.name]) {
        context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      ifaceTypeNames[iface.name] = true;
      validateTypeImplementsAncestors(context, type, iface);
      validateTypeImplementsInterface(context, type, iface);
    }
  };
  var validateTypeImplementsInterface = function(context, type, iface) {
    const typeFieldMap = type.getFields();
    for (const ifaceField of Object.values(iface.getFields())) {
      const fieldName = ifaceField.name;
      const typeField = typeFieldMap[fieldName];
      if (!typeField) {
        context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
        continue;
      }
      if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
        var _ifaceField$astNode, _typeField$astNode;
        context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${(0, _inspect.inspect)(typeField.type)}.`, [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
        ]);
      }
      for (const ifaceArg of ifaceField.args) {
        const argName = ifaceArg.name;
        const typeArg = typeField.args.find((arg) => arg.name === argName);
        if (!typeArg) {
          context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
          continue;
        }
        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
          var _ifaceArg$astNode, _typeArg$astNode;
          context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${(0, _inspect.inspect)(typeArg.type)}.`, [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
          ]);
        }
      }
      for (const typeArg of typeField.args) {
        const argName = typeArg.name;
        const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
        if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
          context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
        }
      }
    }
  };
  var validateTypeImplementsAncestors = function(context, type, iface) {
    const ifaceInterfaces = type.getInterfaces();
    for (const transitive of iface.getInterfaces()) {
      if (!ifaceInterfaces.includes(transitive)) {
        context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]);
      }
    }
  };
  var validateUnionMembers = function(context, union) {
    const memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
    }
    const includedTypeNames = Object.create(null);
    for (const memberType of memberTypes) {
      if (includedTypeNames[memberType.name]) {
        context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
        continue;
      }
      includedTypeNames[memberType.name] = true;
      if (!(0, _definition.isObjectType)(memberType)) {
        context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
      }
    }
  };
  var validateEnumValues = function(context, enumType) {
    const enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
    }
    for (const enumValue of enumValues) {
      validateName(context, enumValue);
    }
  };
  var validateInputFields = function(context, inputObj) {
    const fields = Object.values(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!(0, _definition.isInputType)(field.type)) {
        var _field$astNode2;
        context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
      }
      if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
        var _field$astNode3;
        context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
        ]);
      }
    }
  };
  var createInputObjectCircularRefsValidator = function(context) {
    const visitedTypes = Object.create(null);
    const fieldPath = [];
    const fieldPathIndexByTypeName = Object.create(null);
    return detectCycleRecursive;
    function detectCycleRecursive(inputObj) {
      if (visitedTypes[inputObj.name]) {
        return;
      }
      visitedTypes[inputObj.name] = true;
      fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
      const fields = Object.values(inputObj.getFields());
      for (const field of fields) {
        if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
          const fieldType = field.type.ofType;
          const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
          fieldPath.push(field);
          if (cycleIndex === undefined) {
            detectCycleRecursive(fieldType);
          } else {
            const cyclePath = fieldPath.slice(cycleIndex);
            const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
            context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
          }
          fieldPath.pop();
        }
      }
      fieldPathIndexByTypeName[inputObj.name] = undefined;
    }
  };
  var getAllImplementsInterfaceNodes = function(type, iface) {
    const { astNode, extensionASTNodes } = type;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((typeNode) => {
      var _typeNode$interfaces;
      return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
    }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
  };
  var getUnionMemberTypeNodes = function(union, typeName) {
    const { astNode, extensionASTNodes } = union;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((unionNode) => {
      var _unionNode$types;
      return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
    }).filter((typeNode) => typeNode.name.value === typeName);
  };
  var getDeprecatedDirectiveNode = function(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === _directives.GraphQLDeprecatedDirective.name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidSchema = assertValidSchema;
  exports.validateSchema = validateSchema;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _ast = require_ast();
  var _typeComparators = require_typeComparators();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _schema = require_schema();

  class SchemaValidationContext {
    constructor(schema) {
      this._errors = [];
      this.schema = schema;
    }
    reportError(message, nodes) {
      const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
      this._errors.push(new _GraphQLError.GraphQLError(message, {
        nodes: _nodes
      }));
    }
    getErrors() {
      return this._errors;
    }
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS((exports) => {
  var typeFromAST = function(schema, typeNode) {
    switch (typeNode.kind) {
      case _kinds.Kind.LIST_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLList(innerType);
      }
      case _kinds.Kind.NON_NULL_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLNonNull(innerType);
      }
      case _kinds.Kind.NAMED_TYPE:
        return schema.getType(typeNode.name.value);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.typeFromAST = typeFromAST;
  var _kinds = require_kinds();
  var _definition = require_definition();
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS((exports) => {
  var getFieldDef = function(schema, parentType, fieldNode) {
    const name = fieldNode.name.value;
    if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    }
    if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    }
    if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
      return _introspection.TypeNameMetaFieldDef;
    }
    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
      return parentType.getFields()[name];
    }
  };
  var visitWithTypeInfo = function(typeInfo, visitor) {
    return {
      enter(...args) {
        const node = args[0];
        typeInfo.enter(node);
        const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
        if (fn) {
          const result = fn.apply(visitor, args);
          if (result !== undefined) {
            typeInfo.leave(node);
            if ((0, _ast.isNode)(result)) {
              typeInfo.enter(result);
            }
          }
          return result;
        }
      },
      leave(...args) {
        const node = args[0];
        const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
        let result;
        if (fn) {
          result = fn.apply(visitor, args);
        }
        typeInfo.leave(node);
        return result;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TypeInfo = undefined;
  exports.visitWithTypeInfo = visitWithTypeInfo;
  var _ast = require_ast();
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  var _definition = require_definition();
  var _introspection = require_introspection();
  var _typeFromAST = require_typeFromAST();

  class TypeInfo {
    constructor(schema, initialType, getFieldDefFn) {
      this._schema = schema;
      this._typeStack = [];
      this._parentTypeStack = [];
      this._inputTypeStack = [];
      this._fieldDefStack = [];
      this._defaultValueStack = [];
      this._directive = null;
      this._argument = null;
      this._enumValue = null;
      this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
      if (initialType) {
        if ((0, _definition.isInputType)(initialType)) {
          this._inputTypeStack.push(initialType);
        }
        if ((0, _definition.isCompositeType)(initialType)) {
          this._parentTypeStack.push(initialType);
        }
        if ((0, _definition.isOutputType)(initialType)) {
          this._typeStack.push(initialType);
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0) {
        return this._typeStack[this._typeStack.length - 1];
      }
    }
    getParentType() {
      if (this._parentTypeStack.length > 0) {
        return this._parentTypeStack[this._parentTypeStack.length - 1];
      }
    }
    getInputType() {
      if (this._inputTypeStack.length > 0) {
        return this._inputTypeStack[this._inputTypeStack.length - 1];
      }
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1) {
        return this._inputTypeStack[this._inputTypeStack.length - 2];
      }
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0) {
        return this._fieldDefStack[this._fieldDefStack.length - 1];
      }
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0) {
        return this._defaultValueStack[this._defaultValueStack.length - 1];
      }
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(node) {
      const schema = this._schema;
      switch (node.kind) {
        case _kinds.Kind.SELECTION_SET: {
          const namedType = (0, _definition.getNamedType)(this.getType());
          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);
          break;
        }
        case _kinds.Kind.FIELD: {
          const parentType = this.getParentType();
          let fieldDef;
          let fieldType;
          if (parentType) {
            fieldDef = this._getFieldDef(schema, parentType, node);
            if (fieldDef) {
              fieldType = fieldDef.type;
            }
          }
          this._fieldDefStack.push(fieldDef);
          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);
          break;
        }
        case _kinds.Kind.DIRECTIVE:
          this._directive = schema.getDirective(node.name.value);
          break;
        case _kinds.Kind.OPERATION_DEFINITION: {
          const rootType = schema.getRootType(node.operation);
          this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION: {
          const typeConditionAST = node.typeCondition;
          const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);
          break;
        }
        case _kinds.Kind.VARIABLE_DEFINITION: {
          const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);
          break;
        }
        case _kinds.Kind.ARGUMENT: {
          var _this$getDirective;
          let argDef;
          let argType;
          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
          if (fieldOrDirective) {
            argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
            if (argDef) {
              argType = argDef.type;
            }
          }
          this._argument = argDef;
          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);
          break;
        }
        case _kinds.Kind.LIST: {
          const listType = (0, _definition.getNullableType)(this.getInputType());
          const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
          this._defaultValueStack.push(undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);
          break;
        }
        case _kinds.Kind.OBJECT_FIELD: {
          const objectType = (0, _definition.getNamedType)(this.getInputType());
          let inputFieldType;
          let inputField;
          if ((0, _definition.isInputObjectType)(objectType)) {
            inputField = objectType.getFields()[node.name.value];
            if (inputField) {
              inputFieldType = inputField.type;
            }
          }
          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);
          break;
        }
        case _kinds.Kind.ENUM: {
          const enumType = (0, _definition.getNamedType)(this.getInputType());
          let enumValue;
          if ((0, _definition.isEnumType)(enumType)) {
            enumValue = enumType.getValue(node.value);
          }
          this._enumValue = enumValue;
          break;
        }
        default:
      }
    }
    leave(node) {
      switch (node.kind) {
        case _kinds.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case _kinds.Kind.FIELD:
          this._fieldDefStack.pop();
          this._typeStack.pop();
          break;
        case _kinds.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case _kinds.Kind.OPERATION_DEFINITION:
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case _kinds.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ARGUMENT:
          this._argument = null;
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.LIST:
        case _kinds.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ENUM:
          this._enumValue = null;
          break;
        default:
      }
    }
  }
  exports.TypeInfo = TypeInfo;
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS((exports) => {
  var isDefinitionNode = function(node) {
    return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
  };
  var isExecutableDefinitionNode = function(node) {
    return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
  };
  var isSelectionNode = function(node) {
    return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
  };
  var isValueNode = function(node) {
    return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
  };
  var isConstValueNode = function(node) {
    return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
  };
  var isTypeNode = function(node) {
    return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
  };
  var isTypeSystemDefinitionNode = function(node) {
    return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
  };
  var isTypeDefinitionNode = function(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  };
  var isTypeSystemExtensionNode = function(node) {
    return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
  };
  var isTypeExtensionNode = function(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isConstValueNode = isConstValueNode;
  exports.isDefinitionNode = isDefinitionNode;
  exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
  exports.isSelectionNode = isSelectionNode;
  exports.isTypeDefinitionNode = isTypeDefinitionNode;
  exports.isTypeExtensionNode = isTypeExtensionNode;
  exports.isTypeNode = isTypeNode;
  exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
  exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
  exports.isValueNode = isValueNode;
  var _kinds = require_kinds();
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS((exports) => {
  var ExecutableDefinitionsRule = function(context) {
    return {
      Document(node) {
        for (const definition of node.definitions) {
          if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
            const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
            context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            }));
          }
        }
        return false;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS((exports) => {
  var FieldsOnCorrectTypeRule = function(context) {
    return {
      Field(node) {
        const type = context.getParentType();
        if (type) {
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            const schema = context.getSchema();
            const fieldName = node.name.value;
            let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
            if (suggestion === "") {
              suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));
            }
            context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
              nodes: node
            }));
          }
        }
      }
    };
  };
  var getSuggestedTypeNames = function(schema, type, fieldName) {
    if (!(0, _definition.isAbstractType)(type)) {
      return [];
    }
    const suggestedTypes = new Set;
    const usageCount = Object.create(null);
    for (const possibleType of schema.getPossibleTypes(type)) {
      if (!possibleType.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleType);
      usageCount[possibleType.name] = 1;
      for (const possibleInterface of possibleType.getInterfaces()) {
        var _usageCount$possibleI;
        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleInterface);
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
      }
    }
    return [...suggestedTypes].sort((typeA, typeB) => {
      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
      if (usageCountDiff !== 0) {
        return usageCountDiff;
      }
      if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
        return -1;
      }
      if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
        return 1;
      }
      return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
    }).map((x) => x.name);
  };
  var getSuggestedFieldNames = function(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
      const possibleFieldNames = Object.keys(type.getFields());
      return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
    }
    return [];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
  var _didYouMean = require_didYouMean();
  var _naturalCompare = require_naturalCompare();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS((exports) => {
  var FragmentsOnCompositeTypesRule = function(context) {
    return {
      InlineFragment(node) {
        const typeCondition = node.typeCondition;
        if (typeCondition) {
          const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
          if (type && !(0, _definition.isCompositeType)(type)) {
            const typeStr = (0, _printer.print)(typeCondition);
            context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
              nodes: typeCondition
            }));
          }
        }
      },
      FragmentDefinition(node) {
        const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
        if (type && !(0, _definition.isCompositeType)(type)) {
          const typeStr = (0, _printer.print)(node.typeCondition);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
            nodes: node.typeCondition
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS((exports) => {
  var KnownArgumentNamesRule = function(context) {
    return {
      ...KnownArgumentNamesOnDirectivesRule(context),
      Argument(argNode) {
        const argDef = context.getArgument();
        const fieldDef = context.getFieldDef();
        const parentType = context.getParentType();
        if (!argDef && fieldDef && parentType) {
          const argName = argNode.name.value;
          const knownArgsNames = fieldDef.args.map((arg) => arg.name);
          const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
          context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
            nodes: argNode
          }));
        }
      }
    };
  };
  var KnownArgumentNamesOnDirectivesRule = function(context) {
    const directiveArgs = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
      }
    }
    return {
      Directive(directiveNode) {
        const directiveName = directiveNode.name.value;
        const knownArgs = directiveArgs[directiveName];
        if (directiveNode.arguments && knownArgs) {
          for (const argNode of directiveNode.arguments) {
            const argName = argNode.name.value;
            if (!knownArgs.includes(argName)) {
              const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: argNode
              }));
            }
          }
        }
        return false;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
  exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
  var _didYouMean = require_didYouMean();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _directives = require_directives();
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS((exports) => {
  var KnownDirectivesRule = function(context) {
    const locationsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      locationsMap[directive.name] = directive.locations;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        locationsMap[def.name.value] = def.locations.map((name) => name.value);
      }
    }
    return {
      Directive(node, _key, _parent, _path, ancestors) {
        const name = node.name.value;
        const locations = locationsMap[name];
        if (!locations) {
          context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          }));
          return;
        }
        const candidateLocation = getDirectiveLocationForASTPath(ancestors);
        if (candidateLocation && !locations.includes(candidateLocation)) {
          context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
            nodes: node
          }));
        }
      }
    };
  };
  var getDirectiveLocationForASTPath = function(ancestors) {
    const appliedTo = ancestors[ancestors.length - 1];
    "kind" in appliedTo || (0, _invariant.invariant)(false);
    switch (appliedTo.kind) {
      case _kinds.Kind.OPERATION_DEFINITION:
        return getDirectiveLocationForOperation(appliedTo.operation);
      case _kinds.Kind.FIELD:
        return _directiveLocation.DirectiveLocation.FIELD;
      case _kinds.Kind.FRAGMENT_SPREAD:
        return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
      case _kinds.Kind.INLINE_FRAGMENT:
        return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
      case _kinds.Kind.FRAGMENT_DEFINITION:
        return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
      case _kinds.Kind.VARIABLE_DEFINITION:
        return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
      case _kinds.Kind.SCHEMA_DEFINITION:
      case _kinds.Kind.SCHEMA_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCHEMA;
      case _kinds.Kind.SCALAR_TYPE_DEFINITION:
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCALAR;
      case _kinds.Kind.OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.OBJECT;
      case _kinds.Kind.FIELD_DEFINITION:
        return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INTERFACE;
      case _kinds.Kind.UNION_TYPE_DEFINITION:
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.UNION;
      case _kinds.Kind.ENUM_TYPE_DEFINITION:
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.ENUM;
      case _kinds.Kind.ENUM_VALUE_DEFINITION:
        return _directiveLocation.DirectiveLocation.ENUM_VALUE;
      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
      case _kinds.Kind.INPUT_VALUE_DEFINITION: {
        const parentNode = ancestors[ancestors.length - 3];
        "kind" in parentNode || (0, _invariant.invariant)(false);
        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
      }
      default:
        (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
    }
  };
  var getDirectiveLocationForOperation = function(operation) {
    switch (operation) {
      case _ast.OperationTypeNode.QUERY:
        return _directiveLocation.DirectiveLocation.QUERY;
      case _ast.OperationTypeNode.MUTATION:
        return _directiveLocation.DirectiveLocation.MUTATION;
      case _ast.OperationTypeNode.SUBSCRIPTION:
        return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownDirectivesRule = KnownDirectivesRule;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
  var _ast = require_ast();
  var _directiveLocation = require_directiveLocation();
  var _kinds = require_kinds();
  var _directives = require_directives();
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS((exports) => {
  var KnownFragmentNamesRule = function(context) {
    return {
      FragmentSpread(node) {
        const fragmentName = node.name.value;
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS((exports) => {
  var KnownTypeNamesRule = function(context) {
    const schema = context.getSchema();
    const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions) {
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = true;
      }
    }
    const typeNames = [
      ...Object.keys(existingTypesMap),
      ...Object.keys(definedTypes)
    ];
    return {
      NamedType(node, _1, parent, _2, ancestors) {
        const typeName = node.name.value;
        if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
          var _ancestors$;
          const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
          const isSDL = definitionNode != null && isSDLNode(definitionNode);
          if (isSDL && standardTypeNames.includes(typeName)) {
            return;
          }
          const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
          context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
            nodes: node
          }));
        }
      }
    };
  };
  var isSDLNode = function(value) {
    return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownTypeNamesRule = KnownTypeNamesRule;
  var _didYouMean = require_didYouMean();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _predicates = require_predicates();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var standardTypeNames = [
    ..._scalars.specifiedScalarTypes,
    ..._introspection.introspectionTypes
  ].map((type) => type.name);
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS((exports) => {
  var LoneAnonymousOperationRule = function(context) {
    let operationCount = 0;
    return {
      Document(node) {
        operationCount = node.definitions.filter((definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
      },
      OperationDefinition(node) {
        if (!node.name && operationCount > 1) {
          context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
            nodes: node
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS((exports) => {
  var LoneSchemaDefinitionRule = function(context) {
    var _ref, _ref2, _oldSchema$astNode;
    const oldSchema = context.getSchema();
    const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
    let schemaDefinitionsCount = 0;
    return {
      SchemaDefinition(node) {
        if (alreadyDefined) {
          context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
            nodes: node
          }));
          return;
        }
        if (schemaDefinitionsCount > 0) {
          context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
            nodes: node
          }));
        }
        ++schemaDefinitionsCount;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS((exports) => {
  var NoFragmentCyclesRule = function(context) {
    const visitedFrags = Object.create(null);
    const spreadPath = [];
    const spreadPathIndexByName = Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        detectCycleRecursive(node);
        return false;
      }
    };
    function detectCycleRecursive(fragment) {
      if (visitedFrags[fragment.name.value]) {
        return;
      }
      const fragmentName = fragment.name.value;
      visitedFrags[fragmentName] = true;
      const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
      if (spreadNodes.length === 0) {
        return;
      }
      spreadPathIndexByName[fragmentName] = spreadPath.length;
      for (const spreadNode of spreadNodes) {
        const spreadName = spreadNode.name.value;
        const cycleIndex = spreadPathIndexByName[spreadName];
        spreadPath.push(spreadNode);
        if (cycleIndex === undefined) {
          const spreadFragment = context.getFragment(spreadName);
          if (spreadFragment) {
            detectCycleRecursive(spreadFragment);
          }
        } else {
          const cyclePath = spreadPath.slice(cycleIndex);
          const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
          context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
            nodes: cyclePath
          }));
        }
        spreadPath.pop();
      }
      spreadPathIndexByName[fragmentName] = undefined;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS((exports) => {
  var NoUndefinedVariablesRule = function(context) {
    let variableNameDefined = Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          variableNameDefined = Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            const varName = node.name.value;
            if (variableNameDefined[varName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
                nodes: [node, operation]
              }));
            }
          }
        }
      },
      VariableDefinition(node) {
        variableNameDefined[node.variable.name.value] = true;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS((exports) => {
  var NoUnusedFragmentsRule = function(context) {
    const operationDefs = [];
    const fragmentDefs = [];
    return {
      OperationDefinition(node) {
        operationDefs.push(node);
        return false;
      },
      FragmentDefinition(node) {
        fragmentDefs.push(node);
        return false;
      },
      Document: {
        leave() {
          const fragmentNameUsed = Object.create(null);
          for (const operation of operationDefs) {
            for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
              fragmentNameUsed[fragment.name.value] = true;
            }
          }
          for (const fragmentDef of fragmentDefs) {
            const fragName = fragmentDef.name.value;
            if (fragmentNameUsed[fragName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              }));
            }
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS((exports) => {
  var NoUnusedVariablesRule = function(context) {
    let variableDefs = [];
    return {
      OperationDefinition: {
        enter() {
          variableDefs = [];
        },
        leave(operation) {
          const variableNameUsed = Object.create(null);
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            variableNameUsed[node.name.value] = true;
          }
          for (const variableDef of variableDefs) {
            const variableName = variableDef.variable.name.value;
            if (variableNameUsed[variableName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
                nodes: variableDef
              }));
            }
          }
        }
      },
      VariableDefinition(def) {
        variableDefs.push(def);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS((exports) => {
  var sortValueNode = function(valueNode) {
    switch (valueNode.kind) {
      case _kinds.Kind.OBJECT:
        return { ...valueNode, fields: sortFields(valueNode.fields) };
      case _kinds.Kind.LIST:
        return { ...valueNode, values: valueNode.values.map(sortValueNode) };
      case _kinds.Kind.INT:
      case _kinds.Kind.FLOAT:
      case _kinds.Kind.STRING:
      case _kinds.Kind.BOOLEAN:
      case _kinds.Kind.NULL:
      case _kinds.Kind.ENUM:
      case _kinds.Kind.VARIABLE:
        return valueNode;
    }
  };
  var sortFields = function(fields) {
    return fields.map((fieldNode) => ({
      ...fieldNode,
      value: sortValueNode(fieldNode.value)
    })).sort((fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortValueNode = sortValueNode;
  var _naturalCompare = require_naturalCompare();
  var _kinds = require_kinds();
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS((exports) => {
  var reasonMessage = function(reason) {
    if (Array.isArray(reason)) {
      return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
    }
    return reason;
  };
  var OverlappingFieldsCanBeMergedRule = function(context) {
    const comparedFragmentPairs = new PairSet;
    const cachedFieldsAndFragmentNames = new Map;
    return {
      SelectionSet(selectionSet) {
        const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
        for (const [[responseName, reason], fields1, fields2] of conflicts) {
          const reasonMsg = reasonMessage(reason);
          context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
            nodes: fields1.concat(fields2)
          }));
        }
      }
    };
  };
  var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    const conflicts = [];
    const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
      for (let i = 0;i < fragmentNames.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
        for (let j = i + 1;j < fragmentNames.length; j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
        }
      }
    }
    return conflicts;
  };
  var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    const fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
    for (const referencedFragmentName of referencedFragmentNames) {
      if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
        continue;
      }
      comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
    }
  };
  var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    const fragment1 = context.getFragment(fragmentName1);
    const fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
    const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (const referencedFragmentName2 of referencedFragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
    }
    for (const referencedFragmentName1 of referencedFragmentNames1) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
    }
  };
  var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    const conflicts = [];
    const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
    const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
    }
    for (const fragmentName1 of fragmentNames1) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
    }
    for (const fragmentName1 of fragmentNames1) {
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
      }
    }
    return conflicts;
  };
  var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    for (const [responseName, fields] of Object.entries(fieldMap)) {
      if (fields.length > 1) {
        for (let i = 0;i < fields.length; i++) {
          for (let j = i + 1;j < fields.length; j++) {
            const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  };
  var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    for (const [responseName, fields1] of Object.entries(fieldMap1)) {
      const fields2 = fieldMap2[responseName];
      if (fields2) {
        for (const field1 of fields1) {
          for (const field2 of fields2) {
            const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  };
  var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    const [parentType1, node1, def1] = field1;
    const [parentType2, node2, def2] = field2;
    const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    if (!areMutuallyExclusive) {
      const name1 = node1.name.value;
      const name2 = node2.name.value;
      if (name1 !== name2) {
        return [
          [responseName, `"${name1}" and "${name2}" are different fields`],
          [node1],
          [node2]
        ];
      }
      if (!sameArguments(node1, node2)) {
        return [
          [responseName, "they have differing arguments"],
          [node1],
          [node2]
        ];
      }
    }
    const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
    const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [
        [
          responseName,
          `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
        ],
        [node1],
        [node2]
      ];
    }
    const selectionSet1 = node1.selectionSet;
    const selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  };
  var sameArguments = function(node1, node2) {
    const args1 = node1.arguments;
    const args2 = node2.arguments;
    if (args1 === undefined || args1.length === 0) {
      return args2 === undefined || args2.length === 0;
    }
    if (args2 === undefined || args2.length === 0) {
      return false;
    }
    if (args1.length !== args2.length) {
      return false;
    }
    const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
    return args1.every((arg1) => {
      const value1 = arg1.value;
      const value2 = values2.get(arg1.name.value);
      if (value2 === undefined) {
        return false;
      }
      return stringifyValue(value1) === stringifyValue(value2);
    });
  };
  var stringifyValue = function(value) {
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));
  };
  var doTypesConflict = function(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
      return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
      return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
      return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
      return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
      return type1 !== type2;
    }
    return false;
  };
  var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    const cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (cached) {
      return cached;
    }
    const nodeAndDefs = Object.create(null);
    const fragmentNames = Object.create(null);
    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
    const result = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, result);
    return result;
  };
  var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
    const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
  };
  var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          const fieldName = selection.name.value;
          let fieldDef;
          if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          const responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case _kinds.Kind.INLINE_FRAGMENT: {
          const typeCondition = selection.typeCondition;
          const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
          break;
        }
      }
    }
  };
  var subfieldConflicts = function(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [
        [responseName, conflicts.map(([reason]) => reason)],
        [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
        [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
      ];
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _sortValueNode = require_sortValueNode();
  var _typeFromAST = require_typeFromAST();

  class PairSet {
    constructor() {
      this._data = new Map;
    }
    has(a, b, areMutuallyExclusive) {
      var _this$_data$get;
      const [key1, key2] = a < b ? [a, b] : [b, a];
      const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
      if (result === undefined) {
        return false;
      }
      return areMutuallyExclusive ? true : areMutuallyExclusive === result;
    }
    add(a, b, areMutuallyExclusive) {
      const [key1, key2] = a < b ? [a, b] : [b, a];
      const map = this._data.get(key1);
      if (map === undefined) {
        this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
      } else {
        map.set(key2, areMutuallyExclusive);
      }
    }
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS((exports) => {
  var PossibleFragmentSpreadsRule = function(context) {
    return {
      InlineFragment(node) {
        const fragType = context.getType();
        const parentType = context.getParentType();
        if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = (0, _inspect.inspect)(parentType);
          const fragTypeStr = (0, _inspect.inspect)(fragType);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
            nodes: node
          }));
        }
      },
      FragmentSpread(node) {
        const fragName = node.name.value;
        const fragType = getFragmentType(context, fragName);
        const parentType = context.getParentType();
        if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = (0, _inspect.inspect)(parentType);
          const fragTypeStr = (0, _inspect.inspect)(fragType);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
            nodes: node
          }));
        }
      }
    };
  };
  var getFragmentType = function(context, name) {
    const frag = context.getFragment(name);
    if (frag) {
      const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
      if ((0, _definition.isCompositeType)(type)) {
        return type;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _typeComparators = require_typeComparators();
  var _typeFromAST = require_typeFromAST();
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS((exports) => {
  var PossibleTypeExtensionsRule = function(context) {
    const schema = context.getSchema();
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions) {
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = def;
      }
    }
    return {
      ScalarTypeExtension: checkExtension,
      ObjectTypeExtension: checkExtension,
      InterfaceTypeExtension: checkExtension,
      UnionTypeExtension: checkExtension,
      EnumTypeExtension: checkExtension,
      InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node) {
      const typeName = node.name.value;
      const defNode = definedTypes[typeName];
      const existingType = schema === null || schema === undefined ? undefined : schema.getType(typeName);
      let expectedKind;
      if (defNode) {
        expectedKind = defKindToExtKind[defNode.kind];
      } else if (existingType) {
        expectedKind = typeToExtKind(existingType);
      }
      if (expectedKind) {
        if (expectedKind !== node.kind) {
          const kindStr = extensionKindToTypeName(node.kind);
          context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          }));
        }
      } else {
        const allTypeNames = Object.keys({
          ...definedTypes,
          ...schema === null || schema === undefined ? undefined : schema.getTypeMap()
        });
        const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
        context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
          nodes: node.name
        }));
      }
    }
  };
  var typeToExtKind = function(type) {
    if ((0, _definition.isScalarType)(type)) {
      return _kinds.Kind.SCALAR_TYPE_EXTENSION;
    }
    if ((0, _definition.isObjectType)(type)) {
      return _kinds.Kind.OBJECT_TYPE_EXTENSION;
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
    }
    if ((0, _definition.isUnionType)(type)) {
      return _kinds.Kind.UNION_TYPE_EXTENSION;
    }
    if ((0, _definition.isEnumType)(type)) {
      return _kinds.Kind.ENUM_TYPE_EXTENSION;
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
  };
  var extensionKindToTypeName = function(kind) {
    switch (kind) {
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      default:
        (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _definition = require_definition();
  var defKindToExtKind = {
    [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
    [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
    [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
    [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
    [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
    [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS((exports) => {
  var ProvidedRequiredArgumentsRule = function(context) {
    return {
      ...ProvidedRequiredArgumentsOnDirectivesRule(context),
      Field: {
        leave(fieldNode) {
          var _fieldNode$arguments;
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            return false;
          }
          const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
          for (const argDef of fieldDef.args) {
            if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
              const argTypeStr = (0, _inspect.inspect)(argDef.type);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                nodes: fieldNode
              }));
            }
          }
        }
      }
    };
  };
  var ProvidedRequiredArgumentsOnDirectivesRule = function(context) {
    var _schema$getDirectives;
    const requiredArgsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = (_schema$getDirectives = schema === null || schema === undefined ? undefined : schema.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
      }
    }
    return {
      Directive: {
        leave(directiveNode) {
          const directiveName = directiveNode.name.value;
          const requiredArgs = requiredArgsMap[directiveName];
          if (requiredArgs) {
            var _directiveNode$argume;
            const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
            const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
            for (const [argName, argDef] of Object.entries(requiredArgs)) {
              if (!argNodeMap.has(argName)) {
                const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                  nodes: directiveNode
                }));
              }
            }
          }
        }
      }
    };
  };
  var isRequiredArgumentNode = function(arg) {
    return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
  exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _directives = require_directives();
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS((exports) => {
  var ScalarLeafsRule = function(context) {
    return {
      Field(node) {
        const type = context.getType();
        const selectionSet = node.selectionSet;
        if (type) {
          if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
            if (selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                nodes: selectionSet
              }));
            }
          } else if (!selectionSet) {
            const fieldName = node.name.value;
            const typeStr = (0, _inspect.inspect)(type);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
              nodes: node
            }));
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScalarLeafsRule = ScalarLeafsRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS((exports) => {
  var printPathArray = function(path) {
    return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printPathArray = printPathArray;
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS((exports) => {
  var addPath = function(prev, key, typename) {
    return {
      prev,
      key,
      typename
    };
  };
  var pathToArray = function(path) {
    const flattened = [];
    let curr = path;
    while (curr) {
      flattened.push(curr.key);
      curr = curr.prev;
    }
    return flattened.reverse();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addPath = addPath;
  exports.pathToArray = pathToArray;
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS((exports) => {
  var coerceInputValue = function(inputValue, type, onError = defaultOnError) {
    return coerceInputValueImpl(inputValue, type, onError, undefined);
  };
  var defaultOnError = function(path, invalidValue, error) {
    let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
    if (path.length > 0) {
      errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
    }
    error.message = errorPrefix + ": " + error.message;
    throw error;
  };
  var coerceInputValueImpl = function(inputValue, type, onError, path) {
    if ((0, _definition.isNonNullType)(type)) {
      if (inputValue != null) {
        return coerceInputValueImpl(inputValue, type.ofType, onError, path);
      }
      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type)}" not to be null.`));
      return;
    }
    if (inputValue == null) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      const itemType = type.ofType;
      if ((0, _isIterableObject.isIterableObject)(inputValue)) {
        return Array.from(inputValue, (itemValue, index) => {
          const itemPath = (0, _Path.addPath)(path, index, undefined);
          return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
        });
      }
      return [coerceInputValueImpl(inputValue, itemType, onError, path)];
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}" to be an object.`));
        return;
      }
      const coercedValue = {};
      const fieldDefs = type.getFields();
      for (const field of Object.values(fieldDefs)) {
        const fieldValue = inputValue[field.name];
        if (fieldValue === undefined) {
          if (field.defaultValue !== undefined) {
            coercedValue[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            const typeStr = (0, _inspect.inspect)(field.type);
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
          }
          continue;
        }
        coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
      }
      for (const fieldName of Object.keys(inputValue)) {
        if (!fieldDefs[fieldName]) {
          const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
        }
      }
      return coercedValue;
    }
    if ((0, _definition.isLeafType)(type)) {
      let parseResult;
      try {
        parseResult = type.parseValue(inputValue);
      } catch (error) {
        if (error instanceof _GraphQLError.GraphQLError) {
          onError((0, _Path.pathToArray)(path), inputValue, error);
        } else {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          }));
        }
        return;
      }
      if (parseResult === undefined) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}".`));
      }
      return parseResult;
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.coerceInputValue = coerceInputValue;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _Path = require_Path();
  var _printPathArray = require_printPathArray();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS((exports) => {
  var valueFromAST = function(valueNode, type, variables) {
    if (!valueNode) {
      return;
    }
    if (valueNode.kind === _kinds.Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variables == null || variables[variableName] === undefined) {
        return;
      }
      const variableValue = variables[variableName];
      if (variableValue === null && (0, _definition.isNonNullType)(type)) {
        return;
      }
      return variableValue;
    }
    if ((0, _definition.isNonNullType)(type)) {
      if (valueNode.kind === _kinds.Kind.NULL) {
        return;
      }
      return valueFromAST(valueNode, type.ofType, variables);
    }
    if (valueNode.kind === _kinds.Kind.NULL) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      const itemType = type.ofType;
      if (valueNode.kind === _kinds.Kind.LIST) {
        const coercedValues = [];
        for (const itemNode of valueNode.values) {
          if (isMissingVariable(itemNode, variables)) {
            if ((0, _definition.isNonNullType)(itemType)) {
              return;
            }
            coercedValues.push(null);
          } else {
            const itemValue = valueFromAST(itemNode, itemType, variables);
            if (itemValue === undefined) {
              return;
            }
            coercedValues.push(itemValue);
          }
        }
        return coercedValues;
      }
      const coercedValue = valueFromAST(valueNode, itemType, variables);
      if (coercedValue === undefined) {
        return;
      }
      return [coercedValue];
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (valueNode.kind !== _kinds.Kind.OBJECT) {
        return;
      }
      const coercedObj = Object.create(null);
      const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field) => field.name.value);
      for (const field of Object.values(type.getFields())) {
        const fieldNode = fieldNodes[field.name];
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== undefined) {
            coercedObj[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            return;
          }
          continue;
        }
        const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
        if (fieldValue === undefined) {
          return;
        }
        coercedObj[field.name] = fieldValue;
      }
      return coercedObj;
    }
    if ((0, _definition.isLeafType)(type)) {
      let result;
      try {
        result = type.parseLiteral(valueNode, variables);
      } catch (_error) {
        return;
      }
      if (result === undefined) {
        return;
      }
      return result;
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
  };
  var isMissingVariable = function(valueNode, variables) {
    return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromAST = valueFromAST;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _kinds = require_kinds();
  var _definition = require_definition();
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS((exports) => {
  var getVariableValues = function(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === undefined ? undefined : options.maxErrors;
    try {
      const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
        }
        errors.push(error);
      });
      if (errors.length === 0) {
        return {
          coerced
        };
      }
    } catch (error) {
      errors.push(error);
    }
    return {
      errors
    };
  };
  var coerceVariableValues = function(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes) {
      const varName = varDefNode.variable.name.value;
      const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
      if (!(0, _definition.isInputType)(varType)) {
        const varTypeStr = (0, _printer.print)(varDefNode.type);
        onError(new _GraphQLError.GraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
          nodes: varDefNode.type
        }));
        continue;
      }
      if (!hasOwnProperty(inputs, varName)) {
        if (varDefNode.defaultValue) {
          coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
        } else if ((0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(new _GraphQLError.GraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
            nodes: varDefNode
          }));
        }
        continue;
      }
      const value = inputs[varName];
      if (value === null && (0, _definition.isNonNullType)(varType)) {
        const varTypeStr = (0, _inspect.inspect)(varType);
        onError(new _GraphQLError.GraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
          nodes: varDefNode
        }));
        continue;
      }
      coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {
        let prefix = `Variable "\$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
        }
        onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
          nodes: varDefNode,
          originalError: error
        }));
      });
    }
    return coercedValues;
  };
  var getArgumentValues = function(def, node, variableValues) {
    var _node$arguments;
    const coercedValues = {};
    const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
    const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg) => arg.name.value);
    for (const argDef of def.args) {
      const name = argDef.name;
      const argType = argDef.type;
      const argumentNode = argNodeMap[name];
      if (!argumentNode) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if ((0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + "was not provided.", {
            nodes: node
          });
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === _kinds.Kind.NULL;
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
          if (argDef.defaultValue !== undefined) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
              nodes: valueNode
            });
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && (0, _definition.isNonNullType)(argType)) {
        throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" ` + "must not be null.", {
          nodes: valueNode
        });
      }
      const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
      if (coercedValue === undefined) {
        throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
          nodes: valueNode
        });
      }
      coercedValues[name] = coercedValue;
    }
    return coercedValues;
  };
  var getDirectiveValues = function(directiveDef, node, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  };
  var hasOwnProperty = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getArgumentValues = getArgumentValues;
  exports.getDirectiveValues = getDirectiveValues;
  exports.getVariableValues = getVariableValues;
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _printPathArray = require_printPathArray();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _coerceInputValue = require_coerceInputValue();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
});

// node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS((exports) => {
  var collectFields = function(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = new Map;
    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
    return fields;
  };
  var collectSubfields = function(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = new Map;
    const visitedFragmentNames = new Set;
    for (const node of fieldNodes) {
      if (node.selectionSet) {
        collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  };
  var collectFieldsImpl = function(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name = getFieldEntryKey(selection);
          const fieldList = fields.get(name);
          if (fieldList !== undefined) {
            fieldList.push(selection);
          } else {
            fields.set(name, [selection]);
          }
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
      }
    }
  };
  var shouldIncludeNode = function(variableValues, node) {
    const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
      return false;
    }
    const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);
    if ((include === null || include === undefined ? undefined : include.if) === false) {
      return false;
    }
    return true;
  };
  var doesFragmentConditionMatch = function(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if ((0, _definition.isAbstractType)(conditionalType)) {
      return schema.isSubType(conditionalType, type);
    }
    return false;
  };
  var getFieldEntryKey = function(node) {
    return node.alias ? node.alias.value : node.name.value;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.collectFields = collectFields;
  exports.collectSubfields = collectSubfields;
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _directives = require_directives();
  var _typeFromAST = require_typeFromAST();
  var _values = require_values();
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS((exports) => {
  var SingleFieldSubscriptionsRule = function(context) {
    return {
      OperationDefinition(node) {
        if (node.operation === "subscription") {
          const schema = context.getSchema();
          const subscriptionType = schema.getSubscriptionType();
          if (subscriptionType) {
            const operationName = node.name ? node.name.value : null;
            const variableValues = Object.create(null);
            const document = context.getDocument();
            const fragments = Object.create(null);
            for (const definition of document.definitions) {
              if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[definition.name.value] = definition;
              }
            }
            const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node.selectionSet);
            if (fields.size > 1) {
              const fieldSelectionLists = [...fields.values()];
              const extraFieldSelectionLists = fieldSelectionLists.slice(1);
              const extraFieldSelections = extraFieldSelectionLists.flat();
              context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                nodes: extraFieldSelections
              }));
            }
            for (const fieldNodes of fields.values()) {
              const field = fieldNodes[0];
              const fieldName = field.name.value;
              if (fieldName.startsWith("__")) {
                context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                  nodes: fieldNodes
                }));
              }
            }
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _collectFields = require_collectFields();
});

// node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS((exports) => {
  var groupBy = function(list, keyFn) {
    const result = new Map;
    for (const item of list) {
      const key = keyFn(item);
      const group = result.get(key);
      if (group === undefined) {
        result.set(key, [item]);
      } else {
        group.push(item);
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.groupBy = groupBy;
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS((exports) => {
  var UniqueArgumentDefinitionNamesRule = function(context) {
    return {
      DirectiveDefinition(directiveNode) {
        var _directiveNode$argume;
        const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
        return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
      },
      InterfaceTypeDefinition: checkArgUniquenessPerField,
      InterfaceTypeExtension: checkArgUniquenessPerField,
      ObjectTypeDefinition: checkArgUniquenessPerField,
      ObjectTypeExtension: checkArgUniquenessPerField
    };
    function checkArgUniquenessPerField(typeNode) {
      var _typeNode$fields;
      const typeName = typeNode.name.value;
      const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
      for (const fieldDef of fieldNodes) {
        var _fieldDef$arguments;
        const fieldName = fieldDef.name.value;
        const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
        checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
      }
      return false;
    }
    function checkArgUniqueness(parentName, argumentNodes) {
      const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
            nodes: argNodes.map((node) => node.name)
          }));
        }
      }
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS((exports) => {
  var UniqueArgumentNamesRule = function(context) {
    return {
      Field: checkArgUniqueness,
      Directive: checkArgUniqueness
    };
    function checkArgUniqueness(parentNode) {
      var _parentNode$arguments;
      const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
      const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
            nodes: argNodes.map((node) => node.name)
          }));
        }
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS((exports) => {
  var UniqueDirectiveNamesRule = function(context) {
    const knownDirectiveNames = Object.create(null);
    const schema = context.getSchema();
    return {
      DirectiveDefinition(node) {
        const directiveName = node.name.value;
        if (schema !== null && schema !== undefined && schema.getDirective(directiveName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
            nodes: node.name
          }));
          return;
        }
        if (knownDirectiveNames[directiveName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
            nodes: [knownDirectiveNames[directiveName], node.name]
          }));
        } else {
          knownDirectiveNames[directiveName] = node.name;
        }
        return false;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS((exports) => {
  var UniqueDirectivesPerLocationRule = function(context) {
    const uniqueDirectiveMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        uniqueDirectiveMap[def.name.value] = !def.repeatable;
      }
    }
    const schemaDirectives = Object.create(null);
    const typeDirectivesMap = Object.create(null);
    return {
      enter(node) {
        if (!("directives" in node) || !node.directives) {
          return;
        }
        let seenDirectives;
        if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          seenDirectives = schemaDirectives;
        } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
          const typeName = node.name.value;
          seenDirectives = typeDirectivesMap[typeName];
          if (seenDirectives === undefined) {
            typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
          }
        } else {
          seenDirectives = Object.create(null);
        }
        for (const directive of node.directives) {
          const directiveName = directive.name.value;
          if (uniqueDirectiveMap[directiveName]) {
            if (seenDirectives[directiveName]) {
              context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                nodes: [seenDirectives[directiveName], directive]
              }));
            } else {
              seenDirectives[directiveName] = directive;
            }
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _directives = require_directives();
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS((exports) => {
  var UniqueEnumValueNamesRule = function(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownValueNames = Object.create(null);
    return {
      EnumTypeDefinition: checkValueUniqueness,
      EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node) {
      var _node$values;
      const typeName = node.name.value;
      if (!knownValueNames[typeName]) {
        knownValueNames[typeName] = Object.create(null);
      }
      const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
      const valueNames = knownValueNames[typeName];
      for (const valueDef of valueNodes) {
        const valueName = valueDef.name.value;
        const existingType = existingTypeMap[typeName];
        if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
            nodes: valueDef.name
          }));
        } else if (valueNames[valueName]) {
          context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
            nodes: [valueNames[valueName], valueDef.name]
          }));
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS((exports) => {
  var UniqueFieldDefinitionNamesRule = function(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownFieldNames = Object.create(null);
    return {
      InputObjectTypeDefinition: checkFieldUniqueness,
      InputObjectTypeExtension: checkFieldUniqueness,
      InterfaceTypeDefinition: checkFieldUniqueness,
      InterfaceTypeExtension: checkFieldUniqueness,
      ObjectTypeDefinition: checkFieldUniqueness,
      ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node) {
      var _node$fields;
      const typeName = node.name.value;
      if (!knownFieldNames[typeName]) {
        knownFieldNames[typeName] = Object.create(null);
      }
      const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
      const fieldNames = knownFieldNames[typeName];
      for (const fieldDef of fieldNodes) {
        const fieldName = fieldDef.name.value;
        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
            nodes: fieldDef.name
          }));
        } else if (fieldNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
            nodes: [fieldNames[fieldName], fieldDef.name]
          }));
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
      return false;
    }
  };
  var hasField = function(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
      return type.getFields()[fieldName] != null;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS((exports) => {
  var UniqueFragmentNamesRule = function(context) {
    const knownFragmentNames = Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        const fragmentName = node.name.value;
        if (knownFragmentNames[fragmentName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
            nodes: [knownFragmentNames[fragmentName], node.name]
          }));
        } else {
          knownFragmentNames[fragmentName] = node.name;
        }
        return false;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS((exports) => {
  var UniqueInputFieldNamesRule = function(context) {
    const knownNameStack = [];
    let knownNames = Object.create(null);
    return {
      ObjectValue: {
        enter() {
          knownNameStack.push(knownNames);
          knownNames = Object.create(null);
        },
        leave() {
          const prevKnownNames = knownNameStack.pop();
          prevKnownNames || (0, _invariant.invariant)(false);
          knownNames = prevKnownNames;
        }
      },
      ObjectField(node) {
        const fieldName = node.name.value;
        if (knownNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
            nodes: [knownNames[fieldName], node.name]
          }));
        } else {
          knownNames[fieldName] = node.name;
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS((exports) => {
  var UniqueOperationNamesRule = function(context) {
    const knownOperationNames = Object.create(null);
    return {
      OperationDefinition(node) {
        const operationName = node.name;
        if (operationName) {
          if (knownOperationNames[operationName.value]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
              nodes: [
                knownOperationNames[operationName.value],
                operationName
              ]
            }));
          } else {
            knownOperationNames[operationName.value] = operationName;
          }
        }
        return false;
      },
      FragmentDefinition: () => false
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS((exports) => {
  var UniqueOperationTypesRule = function(context) {
    const schema = context.getSchema();
    const definedOperationTypes = Object.create(null);
    const existingOperationTypes = schema ? {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: checkOperationTypes,
      SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        const operation = operationType.operation;
        const alreadyDefinedOperationType = definedOperationTypes[operation];
        if (existingOperationTypes[operation]) {
          context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
            nodes: operationType
          }));
        } else if (alreadyDefinedOperationType) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
            nodes: [alreadyDefinedOperationType, operationType]
          }));
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS((exports) => {
  var UniqueTypeNamesRule = function(context) {
    const knownTypeNames = Object.create(null);
    const schema = context.getSchema();
    return {
      ScalarTypeDefinition: checkTypeName,
      ObjectTypeDefinition: checkTypeName,
      InterfaceTypeDefinition: checkTypeName,
      UnionTypeDefinition: checkTypeName,
      EnumTypeDefinition: checkTypeName,
      InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node) {
      const typeName = node.name.value;
      if (schema !== null && schema !== undefined && schema.getType(typeName)) {
        context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownTypeNames[typeName]) {
        context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        }));
      } else {
        knownTypeNames[typeName] = node.name;
      }
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS((exports) => {
  var UniqueVariableNamesRule = function(context) {
    return {
      OperationDefinition(operationNode) {
        var _operationNode$variab;
        const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
        const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node) => node.variable.name.value);
        for (const [variableName, variableNodes] of seenVariableDefinitions) {
          if (variableNodes.length > 1) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "\$${variableName}".`, {
              nodes: variableNodes.map((node) => node.variable.name)
            }));
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS((exports) => {
  var ValuesOfCorrectTypeRule = function(context) {
    return {
      ListValue(node) {
        const type = (0, _definition.getNullableType)(context.getParentInputType());
        if (!(0, _definition.isListType)(type)) {
          isValidValueNode(context, node);
          return false;
        }
      },
      ObjectValue(node) {
        const type = (0, _definition.getNamedType)(context.getInputType());
        if (!(0, _definition.isInputObjectType)(type)) {
          isValidValueNode(context, node);
          return false;
        }
        const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, (field) => field.name.value);
        for (const fieldDef of Object.values(type.getFields())) {
          const fieldNode = fieldNodeMap[fieldDef.name];
          if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
            const typeStr = (0, _inspect.inspect)(fieldDef.type);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
              nodes: node
            }));
          }
        }
      },
      ObjectField(node) {
        const parentType = (0, _definition.getNamedType)(context.getParentInputType());
        const fieldType = context.getInputType();
        if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
          const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));
          context.reportError(new _GraphQLError.GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
            nodes: node
          }));
        }
      },
      NullValue(node) {
        const type = context.getInputType();
        if ((0, _definition.isNonNullType)(type)) {
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type)}", found ${(0, _printer.print)(node)}.`, {
            nodes: node
          }));
        }
      },
      EnumValue: (node) => isValidValueNode(context, node),
      IntValue: (node) => isValidValueNode(context, node),
      FloatValue: (node) => isValidValueNode(context, node),
      StringValue: (node) => isValidValueNode(context, node),
      BooleanValue: (node) => isValidValueNode(context, node)
    };
  };
  var isValidValueNode = function(context, node) {
    const locationType = context.getInputType();
    if (!locationType) {
      return;
    }
    const type = (0, _definition.getNamedType)(locationType);
    if (!(0, _definition.isLeafType)(type)) {
      const typeStr = (0, _inspect.inspect)(locationType);
      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
        nodes: node
      }));
      return;
    }
    try {
      const parseResult = type.parseLiteral(node, undefined);
      if (parseResult === undefined) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
          nodes: node
        }));
      }
    } catch (error) {
      const typeStr = (0, _inspect.inspect)(locationType);
      if (error instanceof _GraphQLError.GraphQLError) {
        context.reportError(error);
      } else {
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}; ` + error.message, {
          nodes: node,
          originalError: error
        }));
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS((exports) => {
  var VariablesAreInputTypesRule = function(context) {
    return {
      VariableDefinition(node) {
        const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
        if (type !== undefined && !(0, _definition.isInputType)(type)) {
          const variableName = node.variable.name.value;
          const typeName = (0, _printer.print)(node.type);
          context.reportError(new _GraphQLError.GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
            nodes: node.type
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS((exports) => {
  var VariablesInAllowedPositionRule = function(context) {
    let varDefMap = Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          varDefMap = Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node, type, defaultValue } of usages) {
            const varName = node.name.value;
            const varDef = varDefMap[varName];
            if (varDef && type) {
              const schema = context.getSchema();
              const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                const varTypeStr = (0, _inspect.inspect)(varType);
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(new _GraphQLError.GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                  nodes: [varDef, node]
                }));
              }
            }
          }
        }
      },
      VariableDefinition(node) {
        varDefMap[node.variable.name.value] = node;
      }
    };
  };
  var allowedVariableUsage = function(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
      const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
      const hasLocationDefaultValue = locationDefaultValue !== undefined;
      if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
        return false;
      }
      const nullableLocationType = locationType.ofType;
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
    }
    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _typeComparators = require_typeComparators();
  var _typeFromAST = require_typeFromAST();
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.specifiedSDLRules = exports.specifiedRules = undefined;
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var specifiedRules = Object.freeze([
    _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
    _UniqueOperationNamesRule.UniqueOperationNamesRule,
    _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
    _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
    _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
    _ScalarLeafsRule.ScalarLeafsRule,
    _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
    _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
    _KnownFragmentNamesRule.KnownFragmentNamesRule,
    _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
    _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
    _NoFragmentCyclesRule.NoFragmentCyclesRule,
    _UniqueVariableNamesRule.UniqueVariableNamesRule,
    _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
    _NoUnusedVariablesRule.NoUnusedVariablesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _KnownArgumentNamesRule.KnownArgumentNamesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
    _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
    _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
  ]);
  exports.specifiedRules = specifiedRules;
  var specifiedSDLRules = Object.freeze([
    _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
    _UniqueOperationTypesRule.UniqueOperationTypesRule,
    _UniqueTypeNamesRule.UniqueTypeNamesRule,
    _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
    _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
    _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
    _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
    _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
  ]);
  exports.specifiedSDLRules = specifiedSDLRules;
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = undefined;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  var _TypeInfo = require_TypeInfo();

  class ASTValidationContext {
    constructor(ast, onError) {
      this._ast = ast;
      this._fragments = undefined;
      this._fragmentSpreads = new Map;
      this._recursivelyReferencedFragments = new Map;
      this._onError = onError;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(error) {
      this._onError(error);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(name) {
      let fragments;
      if (this._fragments) {
        fragments = this._fragments;
      } else {
        fragments = Object.create(null);
        for (const defNode of this.getDocument().definitions) {
          if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
            fragments[defNode.name.value] = defNode;
          }
        }
        this._fragments = fragments;
      }
      return fragments[name];
    }
    getFragmentSpreads(node) {
      let spreads = this._fragmentSpreads.get(node);
      if (!spreads) {
        spreads = [];
        const setsToVisit = [node];
        let set;
        while (set = setsToVisit.pop()) {
          for (const selection of set.selections) {
            if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
              spreads.push(selection);
            } else if (selection.selectionSet) {
              setsToVisit.push(selection.selectionSet);
            }
          }
        }
        this._fragmentSpreads.set(node, spreads);
      }
      return spreads;
    }
    getRecursivelyReferencedFragments(operation) {
      let fragments = this._recursivelyReferencedFragments.get(operation);
      if (!fragments) {
        fragments = [];
        const collectedNames = Object.create(null);
        const nodesToVisit = [operation.selectionSet];
        let node;
        while (node = nodesToVisit.pop()) {
          for (const spread of this.getFragmentSpreads(node)) {
            const fragName = spread.name.value;
            if (collectedNames[fragName] !== true) {
              collectedNames[fragName] = true;
              const fragment = this.getFragment(fragName);
              if (fragment) {
                fragments.push(fragment);
                nodesToVisit.push(fragment.selectionSet);
              }
            }
          }
        }
        this._recursivelyReferencedFragments.set(operation, fragments);
      }
      return fragments;
    }
  }
  exports.ASTValidationContext = ASTValidationContext;

  class SDLValidationContext extends ASTValidationContext {
    constructor(ast, schema, onError) {
      super(ast, onError);
      this._schema = schema;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  }
  exports.SDLValidationContext = SDLValidationContext;

  class ValidationContext extends ASTValidationContext {
    constructor(schema, ast, typeInfo, onError) {
      super(ast, onError);
      this._schema = schema;
      this._typeInfo = typeInfo;
      this._variableUsages = new Map;
      this._recursiveVariableUsages = new Map;
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(node) {
      let usages = this._variableUsages.get(node);
      if (!usages) {
        const newUsages = [];
        const typeInfo = new _TypeInfo.TypeInfo(this._schema);
        (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        }));
        usages = newUsages;
        this._variableUsages.set(node, usages);
      }
      return usages;
    }
    getRecursiveVariableUsages(operation) {
      let usages = this._recursiveVariableUsages.get(operation);
      if (!usages) {
        usages = this.getVariableUsages(operation);
        for (const frag of this.getRecursivelyReferencedFragments(operation)) {
          usages = usages.concat(this.getVariableUsages(frag));
        }
        this._recursiveVariableUsages.set(operation, usages);
      }
      return usages;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  }
  exports.ValidationContext = ValidationContext;
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS((exports) => {
  var validate = function(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
    var _options$maxErrors;
    const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
    documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    const abortObj = Object.freeze({});
    const errors = [];
    const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error) => {
      if (errors.length >= maxErrors) {
        errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
        throw abortObj;
      }
      errors.push(error);
    });
    const visitor = (0, _visitor.visitInParallel)(rules.map((rule) => rule(context)));
    try {
      (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
    } catch (e) {
      if (e !== abortObj) {
        throw e;
      }
    }
    return errors;
  };
  var validateSDL = function(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
    const errors = [];
    const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error) => {
      errors.push(error);
    });
    const visitors = rules.map((rule) => rule(context));
    (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
    return errors;
  };
  var assertValidSDL = function(documentAST) {
    const errors = validateSDL(documentAST);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  };
  var assertValidSDLExtension = function(documentAST, schema) {
    const errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidSDL = assertValidSDL;
  exports.assertValidSDLExtension = assertValidSDLExtension;
  exports.validate = validate;
  exports.validateSDL = validateSDL;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _visitor = require_visitor();
  var _validate = require_validate();
  var _TypeInfo = require_TypeInfo();
  var _specifiedRules = require_specifiedRules();
  var _ValidationContext = require_ValidationContext();
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS((exports) => {
  var memoize3 = function(fn) {
    let cache0;
    return function memoized(a1, a2, a3) {
      if (cache0 === undefined) {
        cache0 = new WeakMap;
      }
      let cache1 = cache0.get(a1);
      if (cache1 === undefined) {
        cache1 = new WeakMap;
        cache0.set(a1, cache1);
      }
      let cache2 = cache1.get(a2);
      if (cache2 === undefined) {
        cache2 = new WeakMap;
        cache1.set(a2, cache2);
      }
      let fnResult = cache2.get(a3);
      if (fnResult === undefined) {
        fnResult = fn(a1, a2, a3);
        cache2.set(a3, fnResult);
      }
      return fnResult;
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.memoize3 = memoize3;
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS((exports) => {
  var promiseForObject = function(object) {
    return Promise.all(Object.values(object)).then((resolvedValues) => {
      const resolvedObject = Object.create(null);
      for (const [i, key] of Object.keys(object).entries()) {
        resolvedObject[key] = resolvedValues[i];
      }
      return resolvedObject;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.promiseForObject = promiseForObject;
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS((exports) => {
  var promiseReduce = function(values, callbackFn, initialValue) {
    let accumulator = initialValue;
    for (const value of values) {
      accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
    }
    return accumulator;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.promiseReduce = promiseReduce;
  var _isPromise = require_isPromise();
});

// node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS((exports) => {
  var toError = function(thrownValue) {
    return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toError = toError;
  var _inspect = require_inspect();

  class NonErrorThrown extends Error {
    constructor(thrownValue) {
      super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
      this.name = "NonErrorThrown";
      this.thrownValue = thrownValue;
    }
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS((exports) => {
  var locatedError = function(rawOriginalError, nodes, path) {
    var _nodes;
    const originalError = (0, _toError.toError)(rawOriginalError);
    if (isLocatedGraphQLError(originalError)) {
      return originalError;
    }
    return new _GraphQLError.GraphQLError(originalError.message, {
      nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
      source: originalError.source,
      positions: originalError.positions,
      path,
      originalError
    });
  };
  var isLocatedGraphQLError = function(error) {
    return Array.isArray(error.path);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.locatedError = locatedError;
  var _toError = require_toError();
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS((exports) => {
  var execute = function(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const { schema, document, variableValues, rootValue } = args;
    assertValidExecutionArguments(schema, document, variableValues);
    const exeContext = buildExecutionContext(args);
    if (!("schema" in exeContext)) {
      return {
        errors: exeContext
      };
    }
    try {
      const { operation } = exeContext;
      const result = executeOperation(exeContext, operation, rootValue);
      if ((0, _isPromise.isPromise)(result)) {
        return result.then((data) => buildResponse(data, exeContext.errors), (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        });
      }
      return buildResponse(result, exeContext.errors);
    } catch (error) {
      exeContext.errors.push(error);
      return buildResponse(null, exeContext.errors);
    }
  };
  var executeSync = function(args) {
    const result = execute(args);
    if ((0, _isPromise.isPromise)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  };
  var buildResponse = function(data, errors) {
    return errors.length === 0 ? {
      data
    } : {
      errors,
      data
    };
  };
  var assertValidExecutionArguments = function(schema, document, rawVariableValues) {
    document || (0, _devAssert.devAssert)(false, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
  };
  var buildExecutionContext = function(args) {
    var _definition$name, _operation$variableDe;
    const {
      schema,
      document,
      rootValue,
      contextValue,
      variableValues: rawVariableValues,
      operationName,
      fieldResolver,
      typeResolver,
      subscribeFieldResolver
    } = args;
    let operation;
    const fragments = Object.create(null);
    for (const definition of document.definitions) {
      switch (definition.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          if (operationName == null) {
            if (operation !== undefined) {
              return [
                new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
              ];
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
            operation = definition;
          }
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          fragments[definition.name.value] = definition;
          break;
        default:
      }
    }
    if (!operation) {
      if (operationName != null) {
        return [
          new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
        ];
      }
      return [new _GraphQLError.GraphQLError("Must provide an operation.")];
    }
    const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== undefined ? _operation$variableDe : [];
    const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== undefined ? rawVariableValues : {}, {
      maxErrors: 50
    });
    if (coercedVariableValues.errors) {
      return coercedVariableValues.errors;
    }
    return {
      schema,
      fragments,
      rootValue,
      contextValue,
      operation,
      variableValues: coercedVariableValues.coerced,
      fieldResolver: fieldResolver !== null && fieldResolver !== undefined ? fieldResolver : defaultFieldResolver,
      typeResolver: typeResolver !== null && typeResolver !== undefined ? typeResolver : defaultTypeResolver,
      subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== undefined ? subscribeFieldResolver : defaultFieldResolver,
      errors: []
    };
  };
  var executeOperation = function(exeContext, operation, rootValue) {
    const rootType = exeContext.schema.getRootType(operation.operation);
    if (rootType == null) {
      throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
        nodes: operation
      });
    }
    const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
    const path = undefined;
    switch (operation.operation) {
      case _ast.OperationTypeNode.QUERY:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
      case _ast.OperationTypeNode.MUTATION:
        return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
      case _ast.OperationTypeNode.SUBSCRIPTION:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
  };
  var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields) {
    return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes]) => {
      const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
      if (result === undefined) {
        return results;
      }
      if ((0, _isPromise.isPromise)(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    }, Object.create(null));
  };
  var executeFields = function(exeContext, parentType, sourceValue, path, fields) {
    const results = Object.create(null);
    let containsPromise = false;
    try {
      for (const [responseName, fieldNodes] of fields.entries()) {
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== undefined) {
          results[responseName] = result;
          if ((0, _isPromise.isPromise)(result)) {
            containsPromise = true;
          }
        }
      }
    } catch (error) {
      if (containsPromise) {
        return (0, _promiseForObject.promiseForObject)(results).finally(() => {
          throw error;
        });
      }
      throw error;
    }
    if (!containsPromise) {
      return results;
    }
    return (0, _promiseForObject.promiseForObject)(results);
  };
  var executeField = function(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
      return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== undefined ? _fieldDef$resolve : exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    try {
      const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
      const contextValue = exeContext.contextValue;
      const result = resolveFn(source, args, contextValue, info);
      let completed;
      if ((0, _isPromise.isPromise)(result)) {
        completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
      } else {
        completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _isPromise.isPromise)(completed)) {
        return completed.then(undefined, (rawError) => {
          const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
          return handleFieldError(error, returnType, exeContext);
        });
      }
      return completed;
    } catch (rawError) {
      const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
      return handleFieldError(error, returnType, exeContext);
    }
  };
  var buildResolveInfo = function(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {
      fieldName: fieldDef.name,
      fieldNodes,
      returnType: fieldDef.type,
      parentType,
      path,
      schema: exeContext.schema,
      fragments: exeContext.fragments,
      rootValue: exeContext.rootValue,
      operation: exeContext.operation,
      variableValues: exeContext.variableValues
    };
  };
  var handleFieldError = function(error, returnType, exeContext) {
    if ((0, _definition.isNonNullType)(returnType)) {
      throw error;
    }
    exeContext.errors.push(error);
    return null;
  };
  var completeValue = function(exeContext, returnType, fieldNodes, info, path, result) {
    if (result instanceof Error) {
      throw result;
    }
    if ((0, _definition.isNonNullType)(returnType)) {
      const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
      if (completed === null) {
        throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
      }
      return completed;
    }
    if (result == null) {
      return null;
    }
    if ((0, _definition.isListType)(returnType)) {
      return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isLeafType)(returnType)) {
      return completeLeafValue(returnType, result);
    }
    if ((0, _definition.isAbstractType)(returnType)) {
      return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isObjectType)(returnType)) {
      return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
  };
  var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result) {
    if (!(0, _isIterableObject.isIterableObject)(result)) {
      throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    }
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = Array.from(result, (item, index) => {
      const itemPath = (0, _Path.addPath)(path, index, undefined);
      try {
        let completedItem;
        if ((0, _isPromise.isPromise)(item)) {
          completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
        } else {
          completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
        }
        if ((0, _isPromise.isPromise)(completedItem)) {
          containsPromise = true;
          return completedItem.then(undefined, (rawError) => {
            const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error, itemType, exeContext);
          });
        }
        return completedItem;
      } catch (rawError) {
        const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
        return handleFieldError(error, itemType, exeContext);
      }
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
  };
  var completeLeafValue = function(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
      throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to ` + `return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
    }
    return serializedResult;
  };
  var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== undefined ? _returnType$resolveTy : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if ((0, _isPromise.isPromise)(runtimeType)) {
      return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
  };
  var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
    }
    if ((0, _definition.isObjectType)(runtimeTypeName)) {
      throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    if (typeof runtimeTypeName !== "string") {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
        nodes: fieldNodes
      });
    }
    if (!(0, _definition.isObjectType)(runtimeType)) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
        nodes: fieldNodes
      });
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
      throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
        nodes: fieldNodes
      });
    }
    return runtimeType;
  };
  var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result) {
    const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
    if (returnType.isTypeOf) {
      const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
      if ((0, _isPromise.isPromise)(isTypeOf)) {
        return isTypeOf.then((resolvedIsTypeOf) => {
          if (!resolvedIsTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
          return executeFields(exeContext, returnType, result, path, subFieldNodes);
        });
      }
      if (!isTypeOf) {
        throw invalidReturnTypeError(returnType, result, fieldNodes);
      }
    }
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
  };
  var invalidReturnTypeError = function(returnType, result, fieldNodes) {
    return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
      nodes: fieldNodes
    });
  };
  var getFieldDef = function(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
      return _introspection.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidExecutionArguments = assertValidExecutionArguments;
  exports.buildExecutionContext = buildExecutionContext;
  exports.buildResolveInfo = buildResolveInfo;
  exports.defaultTypeResolver = exports.defaultFieldResolver = undefined;
  exports.execute = execute;
  exports.executeSync = executeSync;
  exports.getFieldDef = getFieldDef;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _isPromise = require_isPromise();
  var _memoize = require_memoize3();
  var _Path = require_Path();
  var _promiseForObject = require_promiseForObject();
  var _promiseReduce = require_promiseReduce();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _ast = require_ast();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _introspection = require_introspection();
  var _validate = require_validate();
  var _collectFields = require_collectFields();
  var _values = require_values();
  var collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
  var defaultTypeResolver = function(value, contextValue, info, abstractType) {
    if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
      return value.__typename;
    }
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for (let i = 0;i < possibleTypes.length; i++) {
      const type = possibleTypes[i];
      if (type.isTypeOf) {
        const isTypeOfResult = type.isTypeOf(value, contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOfResult)) {
          promisedIsTypeOfResults[i] = isTypeOfResult;
        } else if (isTypeOfResult) {
          return type.name;
        }
      }
    }
    if (promisedIsTypeOfResults.length) {
      return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
        for (let i = 0;i < isTypeOfResults.length; i++) {
          if (isTypeOfResults[i]) {
            return possibleTypes[i].name;
          }
        }
      });
    }
  };
  exports.defaultTypeResolver = defaultTypeResolver;
  var defaultFieldResolver = function(source, args, contextValue, info) {
    if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
      const property = source[info.fieldName];
      if (typeof property === "function") {
        return source[info.fieldName](args, contextValue, info);
      }
      return property;
    }
  };
  exports.defaultFieldResolver = defaultFieldResolver;
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS((exports) => {
  var graphql = function(args) {
    return new Promise((resolve) => resolve(graphqlImpl(args)));
  };
  var graphqlSync = function(args) {
    const result = graphqlImpl(args);
    if ((0, _isPromise.isPromise)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  };
  var graphqlImpl = function(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const {
      schema,
      source,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    } = args;
    const schemaValidationErrors = (0, _validate.validateSchema)(schema);
    if (schemaValidationErrors.length > 0) {
      return {
        errors: schemaValidationErrors
      };
    }
    let document;
    try {
      document = (0, _parser.parse)(source);
    } catch (syntaxError) {
      return {
        errors: [syntaxError]
      };
    }
    const validationErrors = (0, _validate2.validate)(schema, document);
    if (validationErrors.length > 0) {
      return {
        errors: validationErrors
      };
    }
    return (0, _execute.execute)({
      schema,
      document,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.graphql = graphql;
  exports.graphqlSync = graphqlSync;
  var _devAssert = require_devAssert();
  var _isPromise = require_isPromise();
  var _parser = require_parser();
  var _validate = require_validate();
  var _validate2 = require_validate2();
  var _execute = require_execute();
});

// node_modules/graphql/type/index.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function() {
      return _directives.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
    enumerable: true,
    get: function() {
      return _scalars.GRAPHQL_MAX_INT;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
    enumerable: true,
    get: function() {
      return _scalars.GRAPHQL_MIN_INT;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLID;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function() {
      return _schema.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function() {
      return _introspection.TypeKind;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function() {
      return _introspection.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _introspection.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function() {
      return _introspection.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function() {
      return _introspection.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function() {
      return _introspection.__InputValue;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function() {
      return _introspection.__Schema;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function() {
      return _introspection.__Type;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function() {
      return _introspection.__TypeKind;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function() {
      return _definition.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function() {
      return _definition.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function() {
      return _directives.assertDirective;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function() {
      return _definition.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertEnumValueName", {
    enumerable: true,
    get: function() {
      return _assertName.assertEnumValueName;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function() {
      return _definition.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function() {
      return _definition.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function() {
      return _definition.assertListType;
    }
  });
  Object.defineProperty(exports, "assertName", {
    enumerable: true,
    get: function() {
      return _assertName.assertName;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function() {
      return _definition.assertNamedType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function() {
      return _definition.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function() {
      return _definition.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function() {
      return _definition.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function() {
      return _definition.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function() {
      return _definition.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function() {
      return _schema.assertSchema;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function() {
      return _definition.assertType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function() {
      return _definition.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function() {
      return _validate.assertValidSchema;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function() {
      return _definition.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function() {
      return _definition.getNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function() {
      return _definition.getNullableType;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function() {
      return _introspection.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function() {
      return _definition.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function() {
      return _definition.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function() {
      return _directives.isDirective;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function() {
      return _definition.isEnumType;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function() {
      return _definition.isInputType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function() {
      return _introspection.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function() {
      return _definition.isLeafType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function() {
      return _definition.isListType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function() {
      return _definition.isNamedType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function() {
      return _definition.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function() {
      return _definition.isNullableType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function() {
      return _definition.isObjectType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function() {
      return _definition.isOutputType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function() {
      return _definition.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function() {
      return _definition.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function() {
      return _definition.isScalarType;
    }
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function() {
      return _schema.isSchema;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function() {
      return _directives.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function() {
      return _scalars.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _definition.isType;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function() {
      return _definition.isUnionType;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function() {
      return _definition.isWrappingType;
    }
  });
  Object.defineProperty(exports, "resolveObjMapThunk", {
    enumerable: true,
    get: function() {
      return _definition.resolveObjMapThunk;
    }
  });
  Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
    enumerable: true,
    get: function() {
      return _definition.resolveReadonlyArrayThunk;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function() {
      return _directives.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function() {
      return _scalars.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function() {
      return _validate.validateSchema;
    }
  });
  var _schema = require_schema();
  var _definition = require_definition();
  var _directives = require_directives();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  var _validate = require_validate();
  var _assertName = require_assertName();
});

// node_modules/graphql/language/index.js
var require_language = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function() {
      return _visitor.BREAK;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _directiveLocation.DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function() {
      return _kinds.Kind;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function() {
      return _lexer.Lexer;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function() {
      return _ast.Location;
    }
  });
  Object.defineProperty(exports, "OperationTypeNode", {
    enumerable: true,
    get: function() {
      return _ast.OperationTypeNode;
    }
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function() {
      return _source.Source;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function() {
      return _ast.Token;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function() {
      return _tokenKind.TokenKind;
    }
  });
  Object.defineProperty(exports, "getEnterLeaveForKind", {
    enumerable: true,
    get: function() {
      return _visitor.getEnterLeaveForKind;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function() {
      return _location.getLocation;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function() {
      return _visitor.getVisitFn;
    }
  });
  Object.defineProperty(exports, "isConstValueNode", {
    enumerable: true,
    get: function() {
      return _predicates.isConstValueNode;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function() {
      return _predicates.isValueNode;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parser.parse;
    }
  });
  Object.defineProperty(exports, "parseConstValue", {
    enumerable: true,
    get: function() {
      return _parser.parseConstValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function() {
      return _parser.parseType;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function() {
      return _parser.parseValue;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function() {
      return _printer.print;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function() {
      return _printLocation.printLocation;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function() {
      return _printLocation.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function() {
      return _visitor.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function() {
      return _visitor.visitInParallel;
    }
  });
  var _source = require_source();
  var _location = require_location();
  var _printLocation = require_printLocation();
  var _kinds = require_kinds();
  var _tokenKind = require_tokenKind();
  var _lexer = require_lexer();
  var _parser = require_parser();
  var _printer = require_printer();
  var _visitor = require_visitor();
  var _ast = require_ast();
  var _predicates = require_predicates();
  var _directiveLocation = require_directiveLocation();
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  var isAsyncIterable = function(maybeAsyncIterable) {
    return typeof (maybeAsyncIterable === null || maybeAsyncIterable === undefined ? undefined : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS((exports) => {
  var mapAsyncIterator = function(iterable, callback) {
    const iterator = iterable[Symbol.asyncIterator]();
    async function mapResult(result) {
      if (result.done) {
        return result;
      }
      try {
        return {
          value: await callback(result.value),
          done: false
        };
      } catch (error) {
        if (typeof iterator.return === "function") {
          try {
            await iterator.return();
          } catch (_e) {
          }
        }
        throw error;
      }
    }
    return {
      async next() {
        return mapResult(await iterator.next());
      },
      async return() {
        return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
          value: undefined,
          done: true
        };
      },
      async throw(error) {
        if (typeof iterator.throw === "function") {
          return mapResult(await iterator.throw(error));
        }
        throw error;
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapAsyncIterator = mapAsyncIterator;
});

// node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS((exports) => {
  async function subscribe(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const resultOrStream = await createSourceEventStream(args);
    if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
      return resultOrStream;
    }
    const mapSourceToResponse = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
    return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
  }
  var toNormalizedArgs = function(args) {
    const firstArg = args[0];
    if (firstArg && "document" in firstArg) {
      return firstArg;
    }
    return {
      schema: firstArg,
      document: args[1],
      rootValue: args[2],
      contextValue: args[3],
      variableValues: args[4],
      operationName: args[5],
      subscribeFieldResolver: args[6]
    };
  };
  async function createSourceEventStream(...rawArgs) {
    const args = toNormalizedArgs(rawArgs);
    const { schema, document, variableValues } = args;
    (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
    const exeContext = (0, _execute.buildExecutionContext)(args);
    if (!("schema" in exeContext)) {
      return {
        errors: exeContext
      };
    }
    try {
      const eventStream = await executeSubscription(exeContext);
      if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
        throw new Error("Subscription field must return Async Iterable. " + `Received: ${(0, _inspect.inspect)(eventStream)}.`);
      }
      return eventStream;
    } catch (error) {
      if (error instanceof _GraphQLError.GraphQLError) {
        return {
          errors: [error]
        };
      }
      throw error;
    }
  }
  async function executeSubscription(exeContext) {
    const { schema, fragments, operation, variableValues, rootValue } = exeContext;
    const rootType = schema.getSubscriptionType();
    if (rootType == null) {
      throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
        nodes: operation
      });
    }
    const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
    const [responseName, fieldNodes] = [...rootFields.entries()][0];
    const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
    if (!fieldDef) {
      const fieldName = fieldNodes[0].name.value;
      throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
        nodes: fieldNodes
      });
    }
    const path = (0, _Path.addPath)(undefined, responseName, rootType.name);
    const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
    try {
      var _fieldDef$subscribe;
      const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
      const contextValue = exeContext.contextValue;
      const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== undefined ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
      const eventStream = await resolveFn(rootValue, args, contextValue, info);
      if (eventStream instanceof Error) {
        throw eventStream;
      }
      return eventStream;
    } catch (error) {
      throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
    }
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSourceEventStream = createSourceEventStream;
  exports.subscribe = subscribe;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _isAsyncIterable = require_isAsyncIterable();
  var _Path = require_Path();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _collectFields = require_collectFields();
  var _execute = require_execute();
  var _mapAsyncIterator = require_mapAsyncIterator();
  var _values = require_values();
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function() {
      return _subscribe.createSourceEventStream;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function() {
      return _execute.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function() {
      return _execute.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function() {
      return _execute.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function() {
      return _execute.executeSync;
    }
  });
  Object.defineProperty(exports, "getArgumentValues", {
    enumerable: true,
    get: function() {
      return _values.getArgumentValues;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function() {
      return _values.getDirectiveValues;
    }
  });
  Object.defineProperty(exports, "getVariableValues", {
    enumerable: true,
    get: function() {
      return _values.getVariableValues;
    }
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function() {
      return _Path.pathToArray;
    }
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function() {
      return _subscribe.subscribe;
    }
  });
  var _Path = require_Path();
  var _execute = require_execute();
  var _subscribe = require_subscribe();
  var _values = require_values();
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS((exports) => {
  var NoDeprecatedCustomRule = function(context) {
    return {
      Field(node) {
        const fieldDef = context.getFieldDef();
        const deprecationReason = fieldDef === null || fieldDef === undefined ? undefined : fieldDef.deprecationReason;
        if (fieldDef && deprecationReason != null) {
          const parentType = context.getParentType();
          parentType != null || (0, _invariant.invariant)(false);
          context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
            nodes: node
          }));
        }
      },
      Argument(node) {
        const argDef = context.getArgument();
        const deprecationReason = argDef === null || argDef === undefined ? undefined : argDef.deprecationReason;
        if (argDef && deprecationReason != null) {
          const directiveDef = context.getDirective();
          if (directiveDef != null) {
            context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
              nodes: node
            }));
          } else {
            const parentType = context.getParentType();
            const fieldDef = context.getFieldDef();
            parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
              nodes: node
            }));
          }
        }
      },
      ObjectField(node) {
        const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
        if ((0, _definition.isInputObjectType)(inputObjectDef)) {
          const inputFieldDef = inputObjectDef.getFields()[node.name.value];
          const deprecationReason = inputFieldDef === null || inputFieldDef === undefined ? undefined : inputFieldDef.deprecationReason;
          if (deprecationReason != null) {
            context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
              nodes: node
            }));
          }
        }
      },
      EnumValue(node) {
        const enumValueDef = context.getEnumValue();
        const deprecationReason = enumValueDef === null || enumValueDef === undefined ? undefined : enumValueDef.deprecationReason;
        if (enumValueDef && deprecationReason != null) {
          const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
          enumTypeDef != null || (0, _invariant.invariant)(false);
          context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
            nodes: node
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS((exports) => {
  var NoSchemaIntrospectionCustomRule = function(context) {
    return {
      Field(node) {
        const type = (0, _definition.getNamedType)(context.getType());
        if (type && (0, _introspection.isIntrospectionType)(type)) {
          context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
            nodes: node
          }));
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _introspection = require_introspection();
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function() {
      return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function() {
      return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownArgumentNamesRule.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function() {
      return _KnownDirectivesRule.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownFragmentNamesRule.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownTypeNamesRule.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function() {
      return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function() {
      return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function() {
      return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function() {
      return _NoFragmentCyclesRule.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function() {
      return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function() {
      return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function() {
      return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function() {
      return _NoUnusedVariablesRule.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function() {
      return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function() {
      return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function() {
      return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function() {
      return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function() {
      return _ScalarLeafsRule.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function() {
      return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function() {
      return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueOperationNamesRule.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function() {
      return _UniqueOperationTypesRule.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueTypeNamesRule.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueVariableNamesRule.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function() {
      return _ValidationContext.ValidationContext;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function() {
      return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function() {
      return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function() {
      return _specifiedRules.specifiedRules;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.validate;
    }
  });
  var _validate = require_validate2();
  var _ValidationContext = require_ValidationContext();
  var _specifiedRules = require_specifiedRules();
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
  var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
});

// node_modules/graphql/error/index.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.GraphQLError;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.formatError;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function() {
      return _locatedError.locatedError;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.printError;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function() {
      return _syntaxError.syntaxError;
    }
  });
  var _GraphQLError = require_GraphQLError();
  var _syntaxError = require_syntaxError();
  var _locatedError = require_locatedError();
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS((exports) => {
  var getIntrospectionQuery = function(options) {
    const optionsWithDefault = {
      descriptions: true,
      specifiedByUrl: false,
      directiveIsRepeatable: false,
      schemaDescription: false,
      inputValueDeprecation: false,
      ...options
    };
    const descriptions = optionsWithDefault.descriptions ? "description" : "";
    const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
    const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
    const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
    function inputDeprecation(str) {
      return optionsWithDefault.inputValueDeprecation ? str : "";
    }
    return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getIntrospectionQuery = getIntrospectionQuery;
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS((exports) => {
  var getOperationAST = function(documentAST, operationName) {
    let operation = null;
    for (const definition of documentAST.definitions) {
      if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
        var _definition$name;
        if (operationName == null) {
          if (operation) {
            return null;
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
          return definition;
        }
      }
    }
    return operation;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationAST = getOperationAST;
  var _kinds = require_kinds();
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS((exports) => {
  var getOperationRootType = function(schema, operation) {
    if (operation.operation === "query") {
      const queryType = schema.getQueryType();
      if (!queryType) {
        throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
          nodes: operation
        });
      }
      return queryType;
    }
    if (operation.operation === "mutation") {
      const mutationType = schema.getMutationType();
      if (!mutationType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
          nodes: operation
        });
      }
      return mutationType;
    }
    if (operation.operation === "subscription") {
      const subscriptionType = schema.getSubscriptionType();
      if (!subscriptionType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
          nodes: operation
        });
      }
      return subscriptionType;
    }
    throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
      nodes: operation
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationRootType = getOperationRootType;
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS((exports) => {
  var introspectionFromSchema = function(schema, options) {
    const optionsWithDefaults = {
      specifiedByUrl: true,
      directiveIsRepeatable: true,
      schemaDescription: true,
      inputValueDeprecation: true,
      ...options
    };
    const document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
    const result = (0, _execute.executeSync)({
      schema,
      document
    });
    !result.errors && result.data || (0, _invariant.invariant)(false);
    return result.data;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.introspectionFromSchema = introspectionFromSchema;
  var _invariant = require_invariant();
  var _parser = require_parser();
  var _execute = require_execute();
  var _getIntrospectionQuery = require_getIntrospectionQuery();
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS((exports) => {
  var buildClientSchema = function(introspection, options) {
    (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`);
    const schemaIntrospection = introspection.__schema;
    const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
    for (const stdType of [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ]) {
      if (typeMap[stdType.name]) {
        typeMap[stdType.name] = stdType;
      }
    }
    const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
    const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
    return new _schema.GraphQLSchema({
      description: schemaIntrospection.description,
      query: queryType,
      mutation: mutationType,
      subscription: subscriptionType,
      types: Object.values(typeMap),
      directives,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
    function getType(typeRef) {
      if (typeRef.kind === _introspection.TypeKind.LIST) {
        const itemRef = typeRef.ofType;
        if (!itemRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        return new _definition.GraphQLList(getType(itemRef));
      }
      if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
        const nullableRef = typeRef.ofType;
        if (!nullableRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        const nullableType = getType(nullableRef);
        return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
      }
      return getNamedType(typeRef);
    }
    function getNamedType(typeRef) {
      const typeName = typeRef.name;
      if (!typeName) {
        throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
      }
      const type = typeMap[typeName];
      if (!type) {
        throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
      }
      return type;
    }
    function getObjectType(typeRef) {
      return (0, _definition.assertObjectType)(getNamedType(typeRef));
    }
    function getInterfaceType(typeRef) {
      return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
    }
    function buildType(type) {
      if (type != null && type.name != null && type.kind != null) {
        switch (type.kind) {
          case _introspection.TypeKind.SCALAR:
            return buildScalarDef(type);
          case _introspection.TypeKind.OBJECT:
            return buildObjectDef(type);
          case _introspection.TypeKind.INTERFACE:
            return buildInterfaceDef(type);
          case _introspection.TypeKind.UNION:
            return buildUnionDef(type);
          case _introspection.TypeKind.ENUM:
            return buildEnumDef(type);
          case _introspection.TypeKind.INPUT_OBJECT:
            return buildInputObjectDef(type);
        }
      }
      const typeStr = (0, _inspect.inspect)(type);
      throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
    }
    function buildScalarDef(scalarIntrospection) {
      return new _definition.GraphQLScalarType({
        name: scalarIntrospection.name,
        description: scalarIntrospection.description,
        specifiedByURL: scalarIntrospection.specifiedByURL
      });
    }
    function buildImplementationsList(implementingIntrospection) {
      if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
        return [];
      }
      if (!implementingIntrospection.interfaces) {
        const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
        throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
      }
      return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
      return new _definition.GraphQLObjectType({
        name: objectIntrospection.name,
        description: objectIntrospection.description,
        interfaces: () => buildImplementationsList(objectIntrospection),
        fields: () => buildFieldDefMap(objectIntrospection)
      });
    }
    function buildInterfaceDef(interfaceIntrospection) {
      return new _definition.GraphQLInterfaceType({
        name: interfaceIntrospection.name,
        description: interfaceIntrospection.description,
        interfaces: () => buildImplementationsList(interfaceIntrospection),
        fields: () => buildFieldDefMap(interfaceIntrospection)
      });
    }
    function buildUnionDef(unionIntrospection) {
      if (!unionIntrospection.possibleTypes) {
        const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
        throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
      }
      return new _definition.GraphQLUnionType({
        name: unionIntrospection.name,
        description: unionIntrospection.description,
        types: () => unionIntrospection.possibleTypes.map(getObjectType)
      });
    }
    function buildEnumDef(enumIntrospection) {
      if (!enumIntrospection.enumValues) {
        const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
        throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
      }
      return new _definition.GraphQLEnumType({
        name: enumIntrospection.name,
        description: enumIntrospection.description,
        values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        }))
      });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
      if (!inputObjectIntrospection.inputFields) {
        const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
        throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
      }
      return new _definition.GraphQLInputObjectType({
        name: inputObjectIntrospection.name,
        description: inputObjectIntrospection.description,
        fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
      });
    }
    function buildFieldDefMap(typeIntrospection) {
      if (!typeIntrospection.fields) {
        throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
      }
      return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
    }
    function buildField(fieldIntrospection) {
      const type = getType(fieldIntrospection.type);
      if (!(0, _definition.isOutputType)(type)) {
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
      }
      if (!fieldIntrospection.args) {
        const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
        throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
      }
      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type,
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
      return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
    }
    function buildInputValue(inputValueIntrospection) {
      const type = getType(inputValueIntrospection.type);
      if (!(0, _definition.isInputType)(type)) {
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
      }
      const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;
      return {
        description: inputValueIntrospection.description,
        type,
        defaultValue,
        deprecationReason: inputValueIntrospection.deprecationReason
      };
    }
    function buildDirective(directiveIntrospection) {
      if (!directiveIntrospection.args) {
        const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
        throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
      }
      if (!directiveIntrospection.locations) {
        const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
        throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
      }
      return new _directives.GraphQLDirective({
        name: directiveIntrospection.name,
        description: directiveIntrospection.description,
        isRepeatable: directiveIntrospection.isRepeatable,
        locations: directiveIntrospection.locations.slice(),
        args: buildInputValueDefMap(directiveIntrospection.args)
      });
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildClientSchema = buildClientSchema;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _isObjectLike = require_isObjectLike();
  var _keyValMap = require_keyValMap();
  var _parser = require_parser();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _schema = require_schema();
  var _valueFromAST = require_valueFromAST();
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS((exports) => {
  var extendSchema = function(schema, documentAST, options) {
    (0, _schema.assertSchema)(schema);
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDLExtension)(documentAST, schema);
    }
    const schemaConfig = schema.toConfig();
    const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
    return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
  };
  var extendSchemaImpl = function(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    const typeDefs = [];
    const typeExtensionsMap = Object.create(null);
    const directiveDefs = [];
    let schemaDef;
    const schemaExtensions = [];
    for (const def of documentAST.definitions) {
      if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
        schemaDef = def;
      } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
        schemaExtensions.push(def);
      } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
        typeDefs.push(def);
      } else if ((0, _predicates.isTypeExtensionNode)(def)) {
        const extendedTypeName = def.name.value;
        const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
      } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        directiveDefs.push(def);
      }
    }
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
      return schemaConfig;
    }
    const typeMap = Object.create(null);
    for (const existingType of schemaConfig.types) {
      typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (const typeNode of typeDefs) {
      var _stdTypeMap$name;
      const name = typeNode.name.value;
      typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== undefined ? _stdTypeMap$name : buildType(typeNode);
    }
    const operationTypes = {
      query: schemaConfig.query && replaceNamedType(schemaConfig.query),
      mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
      subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
      ...schemaDef && getOperationTypes([schemaDef]),
      ...getOperationTypes(schemaExtensions)
    };
    return {
      description: (_schemaDef = schemaDef) === null || _schemaDef === undefined ? undefined : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === undefined ? undefined : _schemaDef$descriptio.value,
      ...operationTypes,
      types: Object.values(typeMap),
      directives: [
        ...schemaConfig.directives.map(replaceDirective),
        ...directiveDefs.map(buildDirective)
      ],
      extensions: Object.create(null),
      astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== undefined ? _schemaDef2 : schemaConfig.astNode,
      extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
      assumeValid: (_options$assumeValid = options === null || options === undefined ? undefined : options.assumeValid) !== null && _options$assumeValid !== undefined ? _options$assumeValid : false
    };
    function replaceType(type) {
      if ((0, _definition.isListType)(type)) {
        return new _definition.GraphQLList(replaceType(type.ofType));
      }
      if ((0, _definition.isNonNullType)(type)) {
        return new _definition.GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceDirective(directive) {
      const config = directive.toConfig();
      return new _directives.GraphQLDirective({
        ...config,
        args: (0, _mapValue.mapValue)(config.args, extendArg)
      });
    }
    function extendNamedType(type) {
      if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
        return type;
      }
      if ((0, _definition.isScalarType)(type)) {
        return extendScalarType(type);
      }
      if ((0, _definition.isObjectType)(type)) {
        return extendObjectType(type);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return extendInterfaceType(type);
      }
      if ((0, _definition.isUnionType)(type)) {
        return extendUnionType(type);
      }
      if ((0, _definition.isEnumType)(type)) {
        return extendEnumType(type);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return extendInputObjectType(type);
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
    function extendInputObjectType(type) {
      var _typeExtensionsMap$co;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== undefined ? _typeExtensionsMap$co : [];
      return new _definition.GraphQLInputObjectType({
        ...config,
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, (field) => ({
            ...field,
            type: replaceType(field.type)
          })),
          ...buildInputFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendEnumType(type) {
      var _typeExtensionsMap$ty;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== undefined ? _typeExtensionsMap$ty : [];
      return new _definition.GraphQLEnumType({
        ...config,
        values: { ...config.values, ...buildEnumValueMap(extensions) },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendScalarType(type) {
      var _typeExtensionsMap$co2;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== undefined ? _typeExtensionsMap$co2 : [];
      let specifiedByURL = config.specifiedByURL;
      for (const extensionNode of extensions) {
        var _getSpecifiedByURL;
        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== undefined ? _getSpecifiedByURL : specifiedByURL;
      }
      return new _definition.GraphQLScalarType({
        ...config,
        specifiedByURL,
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendObjectType(type) {
      var _typeExtensionsMap$co3;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== undefined ? _typeExtensionsMap$co3 : [];
      return new _definition.GraphQLObjectType({
        ...config,
        interfaces: () => [
          ...type.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendInterfaceType(type) {
      var _typeExtensionsMap$co4;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== undefined ? _typeExtensionsMap$co4 : [];
      return new _definition.GraphQLInterfaceType({
        ...config,
        interfaces: () => [
          ...type.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendUnionType(type) {
      var _typeExtensionsMap$co5;
      const config = type.toConfig();
      const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== undefined ? _typeExtensionsMap$co5 : [];
      return new _definition.GraphQLUnionType({
        ...config,
        types: () => [
          ...type.getTypes().map(replaceNamedType),
          ...buildUnionTypes(extensions)
        ],
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendField(field) {
      return {
        ...field,
        type: replaceType(field.type),
        args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
      };
    }
    function extendArg(arg) {
      return { ...arg, type: replaceType(arg.type) };
    }
    function getOperationTypes(nodes) {
      const opTypes = {};
      for (const node of nodes) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          opTypes[operationType.operation] = getNamedType(operationType.type);
        }
      }
      return opTypes;
    }
    function getNamedType(node) {
      var _stdTypeMap$name2;
      const name = node.name.value;
      const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== undefined ? _stdTypeMap$name2 : typeMap[name];
      if (type === undefined) {
        throw new Error(`Unknown type: "${name}".`);
      }
      return type;
    }
    function getWrappedType(node) {
      if (node.kind === _kinds.Kind.LIST_TYPE) {
        return new _definition.GraphQLList(getWrappedType(node.type));
      }
      if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
        return new _definition.GraphQLNonNull(getWrappedType(node.type));
      }
      return getNamedType(node);
    }
    function buildDirective(node) {
      var _node$description;
      return new _directives.GraphQLDirective({
        name: node.name.value,
        description: (_node$description = node.description) === null || _node$description === undefined ? undefined : _node$description.value,
        locations: node.locations.map(({ value }) => value),
        isRepeatable: node.repeatable,
        args: buildArgumentMap(node.arguments),
        astNode: node
      });
    }
    function buildFieldMap(nodes) {
      const fieldConfigMap = Object.create(null);
      for (const node of nodes) {
        var _node$fields;
        const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
        for (const field of nodeFields) {
          var _field$description;
          fieldConfigMap[field.name.value] = {
            type: getWrappedType(field.type),
            description: (_field$description = field.description) === null || _field$description === undefined ? undefined : _field$description.value,
            args: buildArgumentMap(field.arguments),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return fieldConfigMap;
    }
    function buildArgumentMap(args) {
      const argsNodes = args !== null && args !== undefined ? args : [];
      const argConfigMap = Object.create(null);
      for (const arg of argsNodes) {
        var _arg$description;
        const type = getWrappedType(arg.type);
        argConfigMap[arg.name.value] = {
          type,
          description: (_arg$description = arg.description) === null || _arg$description === undefined ? undefined : _arg$description.value,
          defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
          deprecationReason: getDeprecationReason(arg),
          astNode: arg
        };
      }
      return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
      const inputFieldMap = Object.create(null);
      for (const node of nodes) {
        var _node$fields2;
        const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== undefined ? _node$fields2 : [];
        for (const field of fieldsNodes) {
          var _field$description2;
          const type = getWrappedType(field.type);
          inputFieldMap[field.name.value] = {
            type,
            description: (_field$description2 = field.description) === null || _field$description2 === undefined ? undefined : _field$description2.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
      const enumValueMap = Object.create(null);
      for (const node of nodes) {
        var _node$values;
        const valuesNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
        for (const value of valuesNodes) {
          var _value$description;
          enumValueMap[value.name.value] = {
            description: (_value$description = value.description) === null || _value$description === undefined ? undefined : _value$description.value,
            deprecationReason: getDeprecationReason(value),
            astNode: value
          };
        }
      }
      return enumValueMap;
    }
    function buildInterfaces(nodes) {
      return nodes.flatMap((node) => {
        var _node$interfaces$map, _node$interfaces;
        return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === undefined ? undefined : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== undefined ? _node$interfaces$map : [];
      });
    }
    function buildUnionTypes(nodes) {
      return nodes.flatMap((node) => {
        var _node$types$map, _node$types;
        return (_node$types$map = (_node$types = node.types) === null || _node$types === undefined ? undefined : _node$types.map(getNamedType)) !== null && _node$types$map !== undefined ? _node$types$map : [];
      });
    }
    function buildType(astNode) {
      var _typeExtensionsMap$na;
      const name = astNode.name.value;
      const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== undefined ? _typeExtensionsMap$na : [];
      switch (astNode.kind) {
        case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
          var _astNode$description;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLObjectType({
            name,
            description: (_astNode$description = astNode.description) === null || _astNode$description === undefined ? undefined : _astNode$description.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
          var _astNode$description2;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLInterfaceType({
            name,
            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === undefined ? undefined : _astNode$description2.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.ENUM_TYPE_DEFINITION: {
          var _astNode$description3;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLEnumType({
            name,
            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === undefined ? undefined : _astNode$description3.value,
            values: buildEnumValueMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.UNION_TYPE_DEFINITION: {
          var _astNode$description4;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLUnionType({
            name,
            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === undefined ? undefined : _astNode$description4.value,
            types: () => buildUnionTypes(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
          var _astNode$description5;
          return new _definition.GraphQLScalarType({
            name,
            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === undefined ? undefined : _astNode$description5.value,
            specifiedByURL: getSpecifiedByURL(astNode),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var _astNode$description6;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLInputObjectType({
            name,
            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === undefined ? undefined : _astNode$description6.value,
            fields: () => buildInputFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
      }
    }
  };
  var getDeprecationReason = function(node) {
    const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
    return deprecated === null || deprecated === undefined ? undefined : deprecated.reason;
  };
  var getSpecifiedByURL = function(node) {
    const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
    return specifiedBy === null || specifiedBy === undefined ? undefined : specifiedBy.url;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.extendSchema = extendSchema;
  exports.extendSchemaImpl = extendSchemaImpl;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _mapValue = require_mapValue();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _schema = require_schema();
  var _validate = require_validate2();
  var _values = require_values();
  var _valueFromAST = require_valueFromAST();
  var stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], (type) => type.name);
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS((exports) => {
  var buildASTSchema = function(documentAST, options) {
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDL)(documentAST);
    }
    const emptySchemaConfig = {
      description: undefined,
      types: [],
      directives: [],
      extensions: Object.create(null),
      extensionASTNodes: [],
      assumeValid: false
    };
    const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
    if (config.astNode == null) {
      for (const type of config.types) {
        switch (type.name) {
          case "Query":
            config.query = type;
            break;
          case "Mutation":
            config.mutation = type;
            break;
          case "Subscription":
            config.subscription = type;
            break;
        }
      }
    }
    const directives = [
      ...config.directives,
      ..._directives.specifiedDirectives.filter((stdDirective) => config.directives.every((directive) => directive.name !== stdDirective.name))
    ];
    return new _schema.GraphQLSchema({ ...config, directives });
  };
  var buildSchema = function(source, options) {
    const document = (0, _parser.parse)(source, {
      noLocation: options === null || options === undefined ? undefined : options.noLocation,
      allowLegacyFragmentVariables: options === null || options === undefined ? undefined : options.allowLegacyFragmentVariables
    });
    return buildASTSchema(document, {
      assumeValidSDL: options === null || options === undefined ? undefined : options.assumeValidSDL,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildASTSchema = buildASTSchema;
  exports.buildSchema = buildSchema;
  var _devAssert = require_devAssert();
  var _kinds = require_kinds();
  var _parser = require_parser();
  var _directives = require_directives();
  var _schema = require_schema();
  var _validate = require_validate2();
  var _extendSchema = require_extendSchema();
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS((exports) => {
  var lexicographicSortSchema = function(schema) {
    const schemaConfig = schema.toConfig();
    const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
    return new _schema.GraphQLSchema({
      ...schemaConfig,
      types: Object.values(typeMap),
      directives: sortByName(schemaConfig.directives).map(sortDirective),
      query: replaceMaybeType(schemaConfig.query),
      mutation: replaceMaybeType(schemaConfig.mutation),
      subscription: replaceMaybeType(schemaConfig.subscription)
    });
    function replaceType(type) {
      if ((0, _definition.isListType)(type)) {
        return new _definition.GraphQLList(replaceType(type.ofType));
      } else if ((0, _definition.isNonNullType)(type)) {
        return new _definition.GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceMaybeType(maybeType) {
      return maybeType && replaceNamedType(maybeType);
    }
    function sortDirective(directive) {
      const config = directive.toConfig();
      return new _directives.GraphQLDirective({
        ...config,
        locations: sortBy(config.locations, (x) => x),
        args: sortArgs(config.args)
      });
    }
    function sortArgs(args) {
      return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
    }
    function sortFields(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => ({
        ...field,
        type: replaceType(field.type),
        args: field.args && sortArgs(field.args)
      }));
    }
    function sortInputFields(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => ({
        ...field,
        type: replaceType(field.type)
      }));
    }
    function sortTypes(array) {
      return sortByName(array).map(replaceNamedType);
    }
    function sortNamedType(type) {
      if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
        return type;
      }
      if ((0, _definition.isObjectType)(type)) {
        const config = type.toConfig();
        return new _definition.GraphQLObjectType({
          ...config,
          interfaces: () => sortTypes(config.interfaces),
          fields: () => sortFields(config.fields)
        });
      }
      if ((0, _definition.isInterfaceType)(type)) {
        const config = type.toConfig();
        return new _definition.GraphQLInterfaceType({
          ...config,
          interfaces: () => sortTypes(config.interfaces),
          fields: () => sortFields(config.fields)
        });
      }
      if ((0, _definition.isUnionType)(type)) {
        const config = type.toConfig();
        return new _definition.GraphQLUnionType({
          ...config,
          types: () => sortTypes(config.types)
        });
      }
      if ((0, _definition.isEnumType)(type)) {
        const config = type.toConfig();
        return new _definition.GraphQLEnumType({
          ...config,
          values: sortObjMap(config.values, (value) => value)
        });
      }
      if ((0, _definition.isInputObjectType)(type)) {
        const config = type.toConfig();
        return new _definition.GraphQLInputObjectType({
          ...config,
          fields: () => sortInputFields(config.fields)
        });
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
  };
  var sortObjMap = function(map, sortValueFn) {
    const sortedMap = Object.create(null);
    for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
      sortedMap[key] = sortValueFn(map[key]);
    }
    return sortedMap;
  };
  var sortByName = function(array) {
    return sortBy(array, (obj) => obj.name);
  };
  var sortBy = function(array, mapToKey) {
    return array.slice().sort((obj1, obj2) => {
      const key1 = mapToKey(obj1);
      const key2 = mapToKey(obj2);
      return (0, _naturalCompare.naturalCompare)(key1, key2);
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.lexicographicSortSchema = lexicographicSortSchema;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyValMap = require_keyValMap();
  var _naturalCompare = require_naturalCompare();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _schema = require_schema();
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS((exports) => {
  var printSchema = function(schema) {
    return printFilteredSchema(schema, (n) => !(0, _directives.isSpecifiedDirective)(n), isDefinedType);
  };
  var printIntrospectionSchema = function(schema) {
    return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
  };
  var isDefinedType = function(type) {
    return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
  };
  var printFilteredSchema = function(schema, directiveFilter, typeFilter) {
    const directives = schema.getDirectives().filter(directiveFilter);
    const types = Object.values(schema.getTypeMap()).filter(typeFilter);
    return [
      printSchemaDefinition(schema),
      ...directives.map((directive) => printDirective(directive)),
      ...types.map((type) => printType(type))
    ].filter(Boolean).join("\n\n");
  };
  var printSchemaDefinition = function(schema) {
    if (schema.description == null && isSchemaOfCommonNames(schema)) {
      return;
    }
    const operationTypes = [];
    const queryType = schema.getQueryType();
    if (queryType) {
      operationTypes.push(`  query: ${queryType.name}`);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
      operationTypes.push(`  mutation: ${mutationType.name}`);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      operationTypes.push(`  subscription: ${subscriptionType.name}`);
    }
    return printDescription(schema) + `schema {\n${operationTypes.join("\n")}\n}`;
  };
  var isSchemaOfCommonNames = function(schema) {
    const queryType = schema.getQueryType();
    if (queryType && queryType.name !== "Query") {
      return false;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== "Mutation") {
      return false;
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.name !== "Subscription") {
      return false;
    }
    return true;
  };
  var printType = function(type) {
    if ((0, _definition.isScalarType)(type)) {
      return printScalar(type);
    }
    if ((0, _definition.isObjectType)(type)) {
      return printObject(type);
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return printInterface(type);
    }
    if ((0, _definition.isUnionType)(type)) {
      return printUnion(type);
    }
    if ((0, _definition.isEnumType)(type)) {
      return printEnum(type);
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return printInputObject(type);
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
  };
  var printScalar = function(type) {
    return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
  };
  var printImplementedInterfaces = function(type) {
    const interfaces = type.getInterfaces();
    return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
  };
  var printObject = function(type) {
    return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
  };
  var printInterface = function(type) {
    return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
  };
  var printUnion = function(type) {
    const types = type.getTypes();
    const possibleTypes = types.length ? " = " + types.join(" | ") : "";
    return printDescription(type) + "union " + type.name + possibleTypes;
  };
  var printEnum = function(type) {
    const values = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
    return printDescription(type) + `enum ${type.name}` + printBlock(values);
  };
  var printInputObject = function(type) {
    const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
    return printDescription(type) + `input ${type.name}` + printBlock(fields);
  };
  var printFields = function(type) {
    const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
    return printBlock(fields);
  };
  var printBlock = function(items) {
    return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
  };
  var printArgs = function(args, indentation = "") {
    if (args.length === 0) {
      return "";
    }
    if (args.every((arg) => !arg.description)) {
      return "(" + args.map(printInputValue).join(", ") + ")";
    }
    return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
  };
  var printInputValue = function(arg) {
    const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
    let argDecl = arg.name + ": " + String(arg.type);
    if (defaultAST) {
      argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
    }
    return argDecl + printDeprecated(arg.deprecationReason);
  };
  var printDirective = function(directive) {
    return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
  };
  var printDeprecated = function(reason) {
    if (reason == null) {
      return "";
    }
    if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: reason
      });
      return ` @deprecated(reason: ${astValue})`;
    }
    return " @deprecated";
  };
  var printSpecifiedByURL = function(scalar) {
    if (scalar.specifiedByURL == null) {
      return "";
    }
    const astValue = (0, _printer.print)({
      kind: _kinds.Kind.STRING,
      value: scalar.specifiedByURL
    });
    return ` @specifiedBy(url: ${astValue})`;
  };
  var printDescription = function(def, indentation = "", firstInBlock = true) {
    const { description } = def;
    if (description == null) {
      return "";
    }
    const blockString = (0, _printer.print)({
      kind: _kinds.Kind.STRING,
      value: description,
      block: (0, _blockString.isPrintableAsBlockString)(description)
    });
    const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
    return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printIntrospectionSchema = printIntrospectionSchema;
  exports.printSchema = printSchema;
  exports.printType = printType;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _blockString = require_blockString();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _astFromValue = require_astFromValue();
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS((exports) => {
  var concatAST = function(documents) {
    const definitions = [];
    for (const doc of documents) {
      definitions.push(...doc.definitions);
    }
    return {
      kind: _kinds.Kind.DOCUMENT,
      definitions
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.concatAST = concatAST;
  var _kinds = require_kinds();
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS((exports) => {
  var separateOperations = function(documentAST) {
    const operations = [];
    const depGraph = Object.create(null);
    for (const definitionNode of documentAST.definitions) {
      switch (definitionNode.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          operations.push(definitionNode);
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
          break;
        default:
      }
    }
    const separatedDocumentASTs = Object.create(null);
    for (const operation of operations) {
      const dependencies = new Set;
      for (const fragmentName of collectDependencies(operation.selectionSet)) {
        collectTransitiveDependencies(dependencies, depGraph, fragmentName);
      }
      const operationName = operation.name ? operation.name.value : "";
      separatedDocumentASTs[operationName] = {
        kind: _kinds.Kind.DOCUMENT,
        definitions: documentAST.definitions.filter((node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
      };
    }
    return separatedDocumentASTs;
  };
  var collectTransitiveDependencies = function(collected, depGraph, fromName) {
    if (!collected.has(fromName)) {
      collected.add(fromName);
      const immediateDeps = depGraph[fromName];
      if (immediateDeps !== undefined) {
        for (const toName of immediateDeps) {
          collectTransitiveDependencies(collected, depGraph, toName);
        }
      }
    }
  };
  var collectDependencies = function(selectionSet) {
    const dependencies = [];
    (0, _visitor.visit)(selectionSet, {
      FragmentSpread(node) {
        dependencies.push(node.name.value);
      }
    });
    return dependencies;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.separateOperations = separateOperations;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS((exports) => {
  var stripIgnoredCharacters = function(source) {
    const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
    const body = sourceObj.body;
    const lexer = new _lexer.Lexer(sourceObj);
    let strippedBody = "";
    let wasLastAddedTokenNonPunctuator = false;
    while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
      const currentToken = lexer.token;
      const tokenKind = currentToken.kind;
      const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
      if (wasLastAddedTokenNonPunctuator) {
        if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
          strippedBody += " ";
        }
      }
      const tokenBody = body.slice(currentToken.start, currentToken.end);
      if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
        strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
          minimize: true
        });
      } else {
        strippedBody += tokenBody;
      }
      wasLastAddedTokenNonPunctuator = isNonPunctuator;
    }
    return strippedBody;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stripIgnoredCharacters = stripIgnoredCharacters;
  var _blockString = require_blockString();
  var _lexer = require_lexer();
  var _source = require_source();
  var _tokenKind = require_tokenKind();
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS((exports) => {
  var assertValidName = function(name) {
    const error = isValidNameError(name);
    if (error) {
      throw error;
    }
    return name;
  };
  var isValidNameError = function(name) {
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.startsWith("__")) {
      return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
    }
    try {
      (0, _assertName.assertName)(name);
    } catch (error) {
      return error;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidName = assertValidName;
  exports.isValidNameError = isValidNameError;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _assertName = require_assertName();
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS((exports) => {
  var findBreakingChanges = function(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter((change) => (change.type in BreakingChangeType));
  };
  var findDangerousChanges = function(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter((change) => (change.type in DangerousChangeType));
  };
  var findSchemaChanges = function(oldSchema, newSchema) {
    return [
      ...findTypeChanges(oldSchema, newSchema),
      ...findDirectiveChanges(oldSchema, newSchema)
    ];
  };
  var findDirectiveChanges = function(oldSchema, newSchema) {
    const schemaChanges = [];
    const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
    for (const oldDirective of directivesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REMOVED,
        description: `${oldDirective.name} was removed.`
      });
    }
    for (const [oldDirective, newDirective] of directivesDiff.persisted) {
      const argsDiff = diff(oldDirective.args, newDirective.args);
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
            description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
          });
        }
      }
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
          description: `${oldArg.name} was removed from ${oldDirective.name}.`
        });
      }
      if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
          description: `Repeatable flag was removed from ${oldDirective.name}.`
        });
      }
      for (const location of oldDirective.locations) {
        if (!newDirective.locations.includes(location)) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
            description: `${location} was removed from ${oldDirective.name}.`
          });
        }
      }
    }
    return schemaChanges;
  };
  var findTypeChanges = function(oldSchema, newSchema) {
    const schemaChanges = [];
    const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
    for (const oldType of typesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED,
        description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
      });
    }
    for (const [oldType, newType] of typesDiff.persisted) {
      if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
        schemaChanges.push(...findEnumTypeChanges(oldType, newType));
      } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
        schemaChanges.push(...findUnionTypeChanges(oldType, newType));
      } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
        schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
      } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
        schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
      } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
        schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
      } else if (oldType.constructor !== newType.constructor) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_CHANGED_KIND,
          description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`
        });
      }
    }
    return schemaChanges;
  };
  var findInputObjectTypeChanges = function(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const newField of fieldsDiff.added) {
      if ((0, _definition.isRequiredInputField)(newField)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
          description: `A required field ${newField.name} on input type ${oldType.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
          description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
        });
      }
    }
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  };
  var findUnionTypeChanges = function(oldType, newType) {
    const schemaChanges = [];
    const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
    for (const newPossibleType of possibleTypesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.TYPE_ADDED_TO_UNION,
        description: `${newPossibleType.name} was added to union type ${oldType.name}.`
      });
    }
    for (const oldPossibleType of possibleTypesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
        description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
      });
    }
    return schemaChanges;
  };
  var findEnumTypeChanges = function(oldType, newType) {
    const schemaChanges = [];
    const valuesDiff = diff(oldType.getValues(), newType.getValues());
    for (const newValue of valuesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
        description: `${newValue.name} was added to enum type ${oldType.name}.`
      });
    }
    for (const oldValue of valuesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
        description: `${oldValue.name} was removed from enum type ${oldType.name}.`
      });
    }
    return schemaChanges;
  };
  var findImplementedInterfacesChanges = function(oldType, newType) {
    const schemaChanges = [];
    const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
    for (const newInterface of interfacesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
        description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
      });
    }
    for (const oldInterface of interfacesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
      });
    }
    return schemaChanges;
  };
  var findFieldChanges = function(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      schemaChanges.push(...findArgChanges(oldType, oldField, newField));
      const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  };
  var findArgChanges = function(oldType, oldField, newField) {
    const schemaChanges = [];
    const argsDiff = diff(oldField.args, newField.args);
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_REMOVED,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
      });
    }
    for (const [oldArg, newArg] of argsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`
        });
      } else if (oldArg.defaultValue !== undefined) {
        if (newArg.defaultValue === undefined) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
          });
        } else {
          const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
          const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
          if (oldValueStr !== newValueStr) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
            });
          }
        }
      }
    }
    for (const newArg of argsDiff.added) {
      if ((0, _definition.isRequiredArgument)(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_ARG_ADDED,
          description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_ARG_ADDED,
          description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      }
    }
    return schemaChanges;
  };
  var isChangeSafeForObjectOrInterfaceField = function(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
  };
  var isChangeSafeForInputObjectFieldOrFieldArg = function(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
  };
  var typeKindName = function(type) {
    if ((0, _definition.isScalarType)(type)) {
      return "a Scalar type";
    }
    if ((0, _definition.isObjectType)(type)) {
      return "an Object type";
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return "an Interface type";
    }
    if ((0, _definition.isUnionType)(type)) {
      return "a Union type";
    }
    if ((0, _definition.isEnumType)(type)) {
      return "an Enum type";
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return "an Input type";
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
  };
  var stringifyValue = function(value, type) {
    const ast = (0, _astFromValue.astFromValue)(value, type);
    ast != null || (0, _invariant.invariant)(false);
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
  };
  var diff = function(oldArray, newArray) {
    const added = [];
    const removed = [];
    const persisted = [];
    const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
    const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
    for (const oldItem of oldArray) {
      const newItem = newMap[oldItem.name];
      if (newItem === undefined) {
        removed.push(oldItem);
      } else {
        persisted.push([oldItem, newItem]);
      }
    }
    for (const newItem of newArray) {
      if (oldMap[newItem.name] === undefined) {
        added.push(newItem);
      }
    }
    return {
      added,
      persisted,
      removed
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DangerousChangeType = exports.BreakingChangeType = undefined;
  exports.findBreakingChanges = findBreakingChanges;
  exports.findDangerousChanges = findDangerousChanges;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _printer = require_printer();
  var _definition = require_definition();
  var _scalars = require_scalars();
  var _astFromValue = require_astFromValue();
  var _sortValueNode = require_sortValueNode();
  var BreakingChangeType;
  exports.BreakingChangeType = BreakingChangeType;
  (function(BreakingChangeType2) {
    BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
    BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
    BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
    BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
    BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
    BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
    BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
    BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
    BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
    BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
    BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
    BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
    BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
    BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
    BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
    BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
  })(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));
  var DangerousChangeType;
  exports.DangerousChangeType = DangerousChangeType;
  (function(DangerousChangeType2) {
    DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
    DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
    DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
    DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
    DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
    DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
  })(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function() {
      return _TypeInfo.TypeInfo;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function() {
      return _assertValidName.assertValidName;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function() {
      return _astFromValue.astFromValue;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function() {
      return _buildASTSchema.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function() {
      return _buildClientSchema.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function() {
      return _buildASTSchema.buildSchema;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function() {
      return _coerceInputValue.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function() {
      return _concatAST.concatAST;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function() {
      return _typeComparators.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function() {
      return _extendSchema.extendSchema;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function() {
      return _getIntrospectionQuery.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function() {
      return _getOperationAST.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function() {
      return _getOperationRootType.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function() {
      return _introspectionFromSchema.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function() {
      return _typeComparators.isEqualType;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function() {
      return _typeComparators.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function() {
      return _assertValidName.isValidNameError;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function() {
      return _lexicographicSortSchema.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function() {
      return _printSchema.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function() {
      return _printSchema.printSchema;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function() {
      return _printSchema.printType;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function() {
      return _separateOperations.separateOperations;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function() {
      return _stripIgnoredCharacters.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function() {
      return _typeFromAST.typeFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function() {
      return _valueFromAST.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function() {
      return _valueFromASTUntyped.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function() {
      return _TypeInfo.visitWithTypeInfo;
    }
  });
  var _getIntrospectionQuery = require_getIntrospectionQuery();
  var _getOperationAST = require_getOperationAST();
  var _getOperationRootType = require_getOperationRootType();
  var _introspectionFromSchema = require_introspectionFromSchema();
  var _buildClientSchema = require_buildClientSchema();
  var _buildASTSchema = require_buildASTSchema();
  var _extendSchema = require_extendSchema();
  var _lexicographicSortSchema = require_lexicographicSortSchema();
  var _printSchema = require_printSchema();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  var _astFromValue = require_astFromValue();
  var _TypeInfo = require_TypeInfo();
  var _coerceInputValue = require_coerceInputValue();
  var _concatAST = require_concatAST();
  var _separateOperations = require_separateOperations();
  var _stripIgnoredCharacters = require_stripIgnoredCharacters();
  var _typeComparators = require_typeComparators();
  var _assertValidName = require_assertValidName();
  var _findBreakingChanges = require_findBreakingChanges();
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function() {
      return _index2.BREAK;
    }
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function() {
      return _index6.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function() {
      return _index.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function() {
      return _index6.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _index2.DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function() {
      return _index4.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _index4.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
    enumerable: true,
    get: function() {
      return _index.GRAPHQL_MAX_INT;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
    enumerable: true,
    get: function() {
      return _index.GRAPHQL_MIN_INT;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function() {
      return _index.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function() {
      return _index5.GraphQLError;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function() {
      return _index.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function() {
      return _index.GraphQLID;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function() {
      return _index.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function() {
      return _index.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function() {
      return _index.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function() {
      return _index2.Kind;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function() {
      return _index2.Lexer;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function() {
      return _index2.Location;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function() {
      return _index4.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function() {
      return _index4.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function() {
      return _index4.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function() {
      return _index4.NoSchemaIntrospectionCustomRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OperationTypeNode", {
    enumerable: true,
    get: function() {
      return _index2.OperationTypeNode;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function() {
      return _index4.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function() {
      return _index4.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function() {
      return _index4.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function() {
      return _index4.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function() {
      return _index4.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function() {
      return _index4.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function() {
      return _index2.Source;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function() {
      return _index2.Token;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function() {
      return _index2.TokenKind;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function() {
      return _index6.TypeInfo;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function() {
      return _index.TypeKind;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueArgumentDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function() {
      return _index4.ValidationContext;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _index4.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function() {
      return _index4.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function() {
      return _index.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _index.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function() {
      return _index.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function() {
      return _index.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function() {
      return _index.__InputValue;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function() {
      return _index.__Schema;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function() {
      return _index.__Type;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function() {
      return _index.__TypeKind;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function() {
      return _index.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function() {
      return _index.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function() {
      return _index.assertDirective;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function() {
      return _index.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertEnumValueName", {
    enumerable: true,
    get: function() {
      return _index.assertEnumValueName;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function() {
      return _index.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function() {
      return _index.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function() {
      return _index.assertListType;
    }
  });
  Object.defineProperty(exports, "assertName", {
    enumerable: true,
    get: function() {
      return _index.assertName;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function() {
      return _index.assertNamedType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function() {
      return _index.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function() {
      return _index.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function() {
      return _index.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function() {
      return _index.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function() {
      return _index.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function() {
      return _index.assertSchema;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function() {
      return _index.assertType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function() {
      return _index.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function() {
      return _index6.assertValidName;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function() {
      return _index.assertValidSchema;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function() {
      return _index.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function() {
      return _index6.astFromValue;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildSchema;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function() {
      return _index6.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function() {
      return _index6.concatAST;
    }
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function() {
      return _index3.createSourceEventStream;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function() {
      return _index3.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function() {
      return _index3.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function() {
      return _index6.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function() {
      return _index3.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function() {
      return _index3.executeSync;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function() {
      return _index6.extendSchema;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function() {
      return _index6.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function() {
      return _index6.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function() {
      return _index5.formatError;
    }
  });
  Object.defineProperty(exports, "getArgumentValues", {
    enumerable: true,
    get: function() {
      return _index3.getArgumentValues;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function() {
      return _index3.getDirectiveValues;
    }
  });
  Object.defineProperty(exports, "getEnterLeaveForKind", {
    enumerable: true,
    get: function() {
      return _index2.getEnterLeaveForKind;
    }
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function() {
      return _index6.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function() {
      return _index2.getLocation;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function() {
      return _index.getNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function() {
      return _index.getNullableType;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function() {
      return _index6.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function() {
      return _index6.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "getVariableValues", {
    enumerable: true,
    get: function() {
      return _index3.getVariableValues;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function() {
      return _index2.getVisitFn;
    }
  });
  Object.defineProperty(exports, "graphql", {
    enumerable: true,
    get: function() {
      return _graphql.graphql;
    }
  });
  Object.defineProperty(exports, "graphqlSync", {
    enumerable: true,
    get: function() {
      return _graphql.graphqlSync;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function() {
      return _index6.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function() {
      return _index.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function() {
      return _index.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function() {
      return _index.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isConstValueNode", {
    enumerable: true,
    get: function() {
      return _index2.isConstValueNode;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function() {
      return _index.isDirective;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function() {
      return _index.isEnumType;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function() {
      return _index6.isEqualType;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function() {
      return _index.isInputType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function() {
      return _index.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function() {
      return _index.isLeafType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function() {
      return _index.isListType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function() {
      return _index.isNamedType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function() {
      return _index.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function() {
      return _index.isNullableType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function() {
      return _index.isObjectType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function() {
      return _index.isOutputType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function() {
      return _index.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function() {
      return _index.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function() {
      return _index.isScalarType;
    }
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function() {
      return _index.isSchema;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function() {
      return _index2.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function() {
      return _index.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function() {
      return _index.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _index.isType;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function() {
      return _index6.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function() {
      return _index.isUnionType;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function() {
      return _index6.isValidNameError;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function() {
      return _index2.isValueNode;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function() {
      return _index.isWrappingType;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function() {
      return _index6.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function() {
      return _index5.locatedError;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _index2.parse;
    }
  });
  Object.defineProperty(exports, "parseConstValue", {
    enumerable: true,
    get: function() {
      return _index2.parseConstValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function() {
      return _index2.parseType;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function() {
      return _index2.parseValue;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function() {
      return _index2.print;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function() {
      return _index5.printError;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function() {
      return _index6.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function() {
      return _index2.printLocation;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function() {
      return _index6.printSchema;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function() {
      return _index2.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function() {
      return _index6.printType;
    }
  });
  Object.defineProperty(exports, "resolveObjMapThunk", {
    enumerable: true,
    get: function() {
      return _index.resolveObjMapThunk;
    }
  });
  Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
    enumerable: true,
    get: function() {
      return _index.resolveReadonlyArrayThunk;
    }
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function() {
      return _index3.responsePathAsArray;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function() {
      return _index6.separateOperations;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function() {
      return _index.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function() {
      return _index4.specifiedRules;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function() {
      return _index.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function() {
      return _index6.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function() {
      return _index3.subscribe;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function() {
      return _index5.syntaxError;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function() {
      return _index6.typeFromAST;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _index4.validate;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function() {
      return _index.validateSchema;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function() {
      return _index6.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function() {
      return _index6.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.version;
    }
  });
  Object.defineProperty(exports, "versionInfo", {
    enumerable: true,
    get: function() {
      return _version.versionInfo;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function() {
      return _index2.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function() {
      return _index2.visitInParallel;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function() {
      return _index6.visitWithTypeInfo;
    }
  });
  var _version = require_version();
  var _graphql = require_graphql();
  var _index = require_type();
  var _index2 = require_language();
  var _index3 = require_execution();
  var _index4 = require_validation();
  var _index5 = require_error();
  var _index6 = require_utilities();
});

// node_modules/value-or-promise/build/main/ValueOrPromise.js
var require_ValueOrPromise = __commonJS((exports) => {
  var isPromiseLike = function(object) {
    return object != null && typeof object.then === "function";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueOrPromise = undefined;
  var defaultOnRejectedFn = (reason) => {
    throw reason;
  };

  class ValueOrPromise {
    constructor(executor2) {
      let value;
      try {
        value = executor2();
      } catch (reason) {
        this.state = { status: "rejected", value: reason };
        return;
      }
      if (isPromiseLike(value)) {
        this.state = { status: "pending", value };
        return;
      }
      this.state = { status: "fulfilled", value };
    }
    then(onFulfilled, onRejected) {
      const state = this.state;
      if (state.status === "pending") {
        return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
      }
      const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
      if (state.status === "rejected") {
        return new ValueOrPromise(() => onRejectedFn(state.value));
      }
      try {
        const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
        return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
      } catch (e) {
        return new ValueOrPromise(() => onRejectedFn(e));
      }
    }
    catch(onRejected) {
      return this.then(undefined, onRejected);
    }
    resolve() {
      const state = this.state;
      if (state.status === "pending") {
        return Promise.resolve(state.value);
      }
      if (state.status === "rejected") {
        throw state.value;
      }
      return state.value;
    }
    static all(valueOrPromises) {
      let rejected = false;
      let reason;
      let containsPromise = false;
      const values = [];
      for (const valueOrPromise of valueOrPromises) {
        const state = valueOrPromise.state;
        if (state.status === "rejected") {
          if (rejected) {
            continue;
          }
          rejected = true;
          reason = state.value;
          continue;
        }
        if (state.status === "pending") {
          containsPromise = true;
        }
        values.push(state.value);
      }
      if (containsPromise) {
        if (rejected) {
          Promise.all(values).catch(() => {
          });
          return new ValueOrPromise(() => {
            throw reason;
          });
        }
        return new ValueOrPromise(() => Promise.all(values));
      }
      return new ValueOrPromise(() => values);
    }
  }
  exports.ValueOrPromise = ValueOrPromise;
});

// node_modules/value-or-promise/build/main/index.js
var require_main = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ValueOrPromise(), exports);
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js
var require_shouldSkipPonyfill = __commonJS((exports, module) => {
  var isNextJs = function() {
    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));
  };
  module.exports = function shouldSkipPonyfill() {
    if (globalThis.Deno) {
      return true;
    }
    if (process.versions.bun) {
      return true;
    }
    if (isNextJs()) {
      return true;
    }
    return false;
  };
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Ae.test(i) || s !== n + 1 && ye.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${S(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (h) => {
      if (l < r.length && r[l].type === h)
        return r[l++].value;
    }, f = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), d = (h) => {
      let u = o(h);
      if (u !== undefined)
        return u;
      let { type: p, index: A } = r[l];
      throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`);
    }, T = () => {
      let h = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        h += u;
      return h;
    }, xe = (h) => h, L = t.encodePart || xe, I = "", U = (h) => {
      I += h;
    }, $ = () => {
      I.length && (a.push(new R(3, "", "", L(I), "", 3)), I = "");
    }, X = (h, u, p, A, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !p && g === 3) {
        U(h);
        return;
      }
      if ($(), !u && !p) {
        if (!h)
          return;
        a.push(new R(3, "", "", L(h), "", g));
        return;
      }
      let m;
      p ? p === "*" ? m = v : m = p : m = n;
      let O = 2;
      m === n ? (O = 1, m = "") : m === v && (O = 0, m = "");
      let P;
      if (u ? P = u : p && (P = c++), i.has(P))
        throw new TypeError(`Duplicate name '${P}'.`);
      i.add(P), a.push(new R(O, P, L(h), m, L(A), g));
    };
    for (;l < r.length; ) {
      let h = o("CHAR"), u = o("NAME"), p = o("REGEX");
      if (!u && !p && (p = o("ASTERISK")), u || p) {
        let g = h ?? "";
        t.prefixes.indexOf(g) === -1 && (U(g), g = ""), $();
        let m = f();
        X(g, u, p, "", m);
        continue;
      }
      let A = h ?? o("ESCAPED_CHAR");
      if (A) {
        U(A);
        continue;
      }
      if (o("OPEN")) {
        let g = T(), m = o("NAME"), O = o("REGEX");
        !m && !O && (O = o("ASTERISK"));
        let P = T();
        d("CLOSE");
        let be = f();
        X(g, m, O, P, be);
        continue;
      }
      $(), d("END");
    }
    return a;
  };
  var S = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var k = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += S(s.value) : n += `(?:${S(s.value)})${k(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${S(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${k(s.modifier)}` : n += `((?:${o})${k(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${S(s.prefix)}(${o})${S(s.suffix)})`, n += k(s.modifier);
        continue;
      }
      n += `(?:${S(s.prefix)}`, n += `((?:${o})(?:`, n += S(s.suffix), n += S(s.prefix), n += `(?:${o}))*)${S(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${S(r.endsWith)}]|\$`, c = `[${S(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : G(e);
  };
  var fe = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : y(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var y = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var he = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var G = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var de = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var pe = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var Se = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var b = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), t.protocol === undefined && (e.protocol = b(n.protocol.substring(0, n.protocol.length - 1), r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && (e.username = b(n.username, r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && t.password === undefined && (e.password = b(n.password, r)), t.protocol === undefined && t.hostname === undefined && (e.hostname = b(n.hostname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && (e.port = b(n.port, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && (e.pathname = b(n.pathname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && (e.search = b(n.search.substring(1, n.search.length), r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && t.hash === undefined && (e.hash = b(n.hash.substring(1, n.hash.length), r));
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = fe(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = b(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${k(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), f = l > 0 ? e[l - 1] : null, d = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && d && !d.prefix.length && !d.suffix.length)
        if (d.type === 3) {
          let T = d.value.length > 0 ? d.value[0] : "";
          o = a.test(T);
        } else
          o = !d.hasCustomName();
      if (!o && !s.prefix.length && f && f.type === 3) {
        let T = f.value[f.value.length - 1];
        o = t.prefixes.includes(T);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!f || f.type === 3 || f.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += k(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Pe = Object.getOwnPropertyDescriptor;
  var Re = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Oe = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ke = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of Re(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Pe(t, a)) || n.enumerable });
    return e;
  };
  var Te = (e) => ke(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Oe(Ne, { URLPattern: () => Y });
  module.exports = Te(Ne);
  var R = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Ae = /[$_\p{ID_Start}]/u;
  var ye = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var x = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var H = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #l = 0;
    #o = 0;
    #d = 0;
    #p = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#o === 0) {
            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);
            continue;
          } else if (this.#o === 2) {
            this.#u(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#d > 0)
          if (this.#A())
            this.#d -= 1;
          else
            continue;
        if (this.#T()) {
          this.#d += 1;
          continue;
        }
        switch (this.#o) {
          case 0:
            this.#P() && this.#u(1);
            break;
          case 1:
            if (this.#P()) {
              this.#C();
              let t = 7, r = 1;
              this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);
            break;
          case 3:
            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);
            break;
          case 4:
            this.#S() && this.#r(5, 1);
            break;
          case 5:
            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 6:
            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 8:
            this.#f() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");
    }
    #r(t, r) {
      switch (this.#o) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#c();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#c();
          break;
        case 4:
          this.#t.password = this.#c();
          break;
        case 5:
          this.#t.hostname = this.#c();
          break;
        case 6:
          this.#t.port = this.#c();
          break;
        case 7:
          this.#t.pathname = this.#c();
          break;
        case 8:
          this.#t.search = this.#c();
          break;
        case 9:
          this.#t.hash = this.#c();
          break;
        case 10:
          break;
      }
      this.#o !== 0 && t !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t === 9 && (this.#t.search ??= "")), this.#R(t, r);
    }
    #R(t, r) {
      this.#o = t, this.#l = this.#e + r, this.#e += r, this.#s = 0;
    }
    #b() {
      this.#e = this.#l, this.#s = 0;
    }
    #u(t) {
      this.#b(), this.#o = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #P() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #S() {
      return this.#a(this.#e, "@");
    }
    #O() {
      return this.#a(this.#e, ":");
    }
    #k() {
      return this.#a(this.#e, ":");
    }
    #x() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #f() {
      return this.#a(this.#e, "#");
    }
    #T() {
      return this.#n[this.#e].type == "OPEN";
    }
    #A() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #y() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #c() {
      let t = this.#n[this.#e], r = this.#m(this.#l).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, x), t.encodePart = y;
      let r = q(this.#c(), undefined, t);
      this.#g = N(r);
    }
  };
  var V = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    #l = false;
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new H(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of V) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, x), i.encodePart = y;
              break;
            case "username":
              Object.assign(i, x), i.encodePart = he;
              break;
            case "password":
              Object.assign(i, x), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, x), i.encodePart = G;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = de) : (Object.assign(i, x, c), i.encodePart = pe);
              break;
            case "search":
              Object.assign(i, x, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, x, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i), this.#l = this.#l || this.#s[s].some((f) => f.type === 2);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of V)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of V) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let f = l[i + 1];
            s[o] = f;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let f of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[f] < o[f])
            return -1;
          if (i[f] === o[f])
            continue;
          return 1;
        }
        return 0;
      }, c = new R(3, "", "", "", "", 3), l = new R(0, "", "", "", "", 3), s = (i, o) => {
        let f = 0;
        for (;f < Math.min(i.length, o.length); ++f) {
          let d = a(i[f], o[f]);
          if (d)
            return d;
        }
        return i.length === o.length ? 0 : a(i[f] ?? c, o[f] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
    get hasRegExpGroups() {
      return this.#l;
    }
  };
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type2 = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type: type2, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type2 = str.slice(0, i).toLowerCase();
    return { type: type2, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode)
      return decode(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = __require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields5 = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields5 === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields5;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = __require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type2 of TYPES) {
      const matched = type2.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type2(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = __require("stream");

  class PonyfillReadableStream {
    constructor(underlyingSource) {
      this.locked = false;
      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        let reader;
        let started = false;
        this.readable = new stream_1.Readable({
          read() {
            if (!started) {
              started = true;
              reader = underlyingSource.getReader();
            }
            reader.read().then(({ value, done }) => {
              if (done) {
                this.push(null);
              } else {
                this.push(value);
              }
            }).catch((err) => {
              this.destroy(err);
            });
          },
          destroy(err, callback) {
            reader.cancel(err).then(() => callback(err), callback);
          }
        });
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          async destroy(err, callback) {
            try {
              await underlyingSource?.cancel?.(err);
              callback(null);
            } catch (err2) {
              callback(err2);
            }
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return Promise.resolve();
    }
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          iterator.return?.();
          this.locked = false;
        },
        cancel: async (reason) => {
          await iterator.return?.(reason);
          this.locked = false;
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    async pipeTo(destination) {
      const writer = destination.getWriter();
      await writer.ready;
      for await (const chunk of this.readable) {
        await writer.write(chunk);
      }
      await writer.ready;
      return writer.close();
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise2 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise2(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise2(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise2(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadable = exports.isArrayBufferView = exports.fakePromise = exports.defaultHeadersSerializer = exports.getHeadersObj = undefined;
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var isBlob = function(obj) {
    return obj != null && obj.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    constructor(blobParts, options) {
      this.blobParts = blobParts;
      this._size = null;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && isBlob(blobParts[0])) {
        return blobParts[0];
      }
    }
    arrayBuffer() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.arrayBuffer();
        }
        return (0, utils_js_1.fakePromise)(getBlobPartAsBuffer(blobPart));
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (isBlob(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    text() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          return (0, utils_js_1.fakePromise)(blobPart);
        }
        if (isBlob(blobPart)) {
          return blobPart.text();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(buf.toString(this.encoding));
      }
      return this.arrayBuffer().then((buf) => buf.toString(this.encoding));
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (isBlob(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.webkitRelativePath = "";
      this.lastModified = options?.lastModified || Date.now();
    }
  }
  exports.PonyfillFile = PonyfillFile;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    Object.defineProperty(blob, "name", {
      configurable: true,
      enumerable: true,
      value: fileName || blob.name || name
    });
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamFromFormData = exports.PonyfillFormData = undefined;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    constructor() {
      this.map = new Map;
    }
    append(name, value, fileName) {
      let values2 = this.map.get(name);
      if (!values2) {
        values2 = [];
        this.map.set(name, values2);
      }
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      values2.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values2 = this.map.get(name);
      return values2 ? values2[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values2] of this.map) {
        for (const value of values2) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values2 of this.map.values()) {
        for (const value of values2) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
  exports.getStreamFromFormData = getStreamFromFormData;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (isReadableStream(bodyInit)) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  var isReadableStream = function(value) {
    return value?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = __require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      this.bodyUsed = false;
      this.contentType = null;
      this.contentLength = null;
      this._bodyFactory = () => null;
      this._generatedBody = null;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    generateBody() {
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _collectChunksFromReadable() {
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      const chunks = [];
      _body.readable.on("data", (chunk) => {
        chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    blob() {
      if (this.bodyType === BodyInitType.Blob) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      if (this._buffer) {
        const blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
      });
    }
    formData(opts) {
      if (this.bodyType === BodyInitType.FormData) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      const formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          formData.set(name, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(formData);
        });
        bb.on("error", (err = "An error occurred while parsing the form data") => {
          const errMessage = err.message || err.toString();
          reject(new TypeError(errMessage, err.cause));
        });
        _body?.readable.pipe(bb);
      });
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
          return this.bodyInit.arrayBuffer();
        }
        const bodyInitTyped = this.bodyInit;
        return bodyInitTyped.arrayBuffer().then((arrayBuffer) => Buffer.from(arrayBuffer, undefined, bodyInitTyped.size));
      }
      return this._collectChunksFromReadable().then(function concatCollectedChunksFromReadable(chunks) {
        if (chunks.length === 1) {
          return chunks[0];
        }
        return Buffer.concat(chunks);
      });
    }
    json() {
      return this.text().then(function parseTextAsJson(text) {
        return JSON.parse(text);
      });
    }
    text() {
      if (this.bodyType === BodyInitType.String) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      return this.arrayBuffer().then((buffer) => buffer.toString("utf-8"));
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillHeaders = exports.isHeadersLike = undefined;
  var util_1 = __require("util");
  exports.isHeadersLike = isHeadersLike;

  class PonyfillHeaders {
    constructor(headersInit) {
      this.headersInit = headersInit;
      this.objectNormalizedKeysOfHeadersInit = [];
      this.objectOriginalKeysOfHeadersInit = [];
      this._setCookies = [];
    }
    _get(key) {
      const normalized = key.toLowerCase();
      if (normalized === "set-cookie") {
        return this._setCookies.join(", ");
      }
      if (this._map) {
        return this._map.get(normalized) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach(([key, value]) => {
              const normalizedKey = key.toLowerCase();
              if (normalizedKey === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(normalizedKey, value);
            });
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              if (key === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                if (normalizedKey === "set-cookie") {
                  this._setCookies.push(initValue);
                  continue;
                }
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies.push(value);
        return;
      }
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value = this._get(name);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name) {
      if (name === "set-cookie") {
        return this._setCookies.length > 0;
      }
      return !!this._get(name);
    }
    set(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [value];
        return;
      }
      this.getMap().set(key, value);
    }
    delete(name) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [];
        return;
      }
      this.getMap().delete(key);
    }
    forEach(callback) {
      this._setCookies.forEach((setCookie) => {
        callback(setCookie, "set-cookie", this);
      });
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    *keys() {
      if (this._setCookies.length) {
        yield "set-cookie";
      }
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.keys();
            return;
          }
          yield* Object.keys(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().keys();
    }
    *values() {
      yield* this._setCookies;
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.values();
            return;
          }
          yield* Object.values(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().values();
    }
    *entries() {
      yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit;
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.entries();
            return;
          }
          yield* Object.entries(this.headersInit);
          return;
        }
      }
      yield* this.getMap().entries();
    }
    getSetCookie() {
      return this._setCookies;
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this._setCookies;
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = __require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    clone() {
      return new PonyfillResponse(this.body, this);
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 301) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    curlHandle.setOpt("SSL_VERIFYPEER", false);
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    return new Promise(function promiseResolver(resolve, reject) {
      let streamResolved;
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          if (curlHandle.isOpen) {
            try {
              curlHandle.pause(CurlPause.Recv);
            } catch (e) {
              reject(e);
            }
          }
        };
      }
      curlHandle.once("end", function endListener() {
        curlHandle.close();
      });
      curlHandle.once("error", function errorListener(error) {
        if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {
          streamResolved.destroy(error);
        } else {
          if (error.message === "Operation was aborted by an application callback") {
            error.message = "The operation was aborted.";
          }
          reject(error);
        }
        curlHandle.close();
      });
      curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
        const pipedStream = stream.pipe(new stream_1.PassThrough);
        const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
          if (headerFilter && !headerFilter.startsWith("HTTP/")) {
            if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
              pipedStream.destroy();
              reject(new Error("redirect is not allowed"));
            }
            return true;
          }
          return false;
        });
        const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
        pipedStream.on("pause", () => {
          stream.pause();
        });
        pipedStream.on("resume", () => {
          stream.resume();
        });
        pipedStream.on("close", () => {
          stream.destroy();
        });
        const ponyfillResponse = new Response_js_1.PonyfillResponse(pipedStream, {
          status,
          headers: headersInit,
          url: fetchRequest.url
        });
        resolve(ponyfillResponse);
        streamResolved = pipedStream;
      });
      curlHandle.perform();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = undefined;
  var stream_1 = __require("stream");
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  exports.fetchCurl = fetchCurl;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillAbortError = undefined;

  class PonyfillAbortError extends Error {
    constructor(reason) {
      let message = "The operation was aborted";
      if (reason) {
        message += ` reason: ${reason}`;
      }
      super(message, {
        cause: reason
      });
      this.name = "AbortError";
    }
    get reason() {
      return this.cause;
    }
  }
  exports.PonyfillAbortError = PonyfillAbortError;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this[_a] = "Request";
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.duplex = requestInit?.duplex || "half";
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (bodyInit == null && !contentLengthInHeaders) {
          this.contentLength = 0;
          this.headers.set("content-length", "0");
        }
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
    }
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return new PonyfillRequest(this);
    }
  }
  exports.PonyfillRequest = PonyfillRequest;
  _a = Symbol.toStringTag;
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type2 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type2];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse2 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse2;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type2 = typeof value;
    if (type2 === "string") {
      return encodeString(value);
    } else if (type2 === "bigint") {
      return value.toString();
    } else if (type2 === "boolean") {
      return value ? "true" : "false";
    } else if (type2 === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse2,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse2;
  module.exports.stringify = stringify;
});

// node_modules/@kamilkisiela/fast-url-parser/src/punycode.js
var require_punycode = __commonJS((exports, module) => {
  var error = function(type2) {
    throw new RangeError(errors4[type2]);
  };
  var map = function(array, callback) {
    var result = [];
    var length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  };
  var mapDomain = function(domain, callback) {
    var parts = domain.split("@");
    var result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    var labels = domain.split(".");
    var encoded = map(labels, callback).join(".");
    return result + encoded;
  };
  var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors4 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag !== 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var encode = function(input) {
    var output = [];
    input = ucs2decode(input);
    var inputLength = input.length;
    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    for (var currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    var basicLength = output.length;
    var handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      var m = maxInt;
      for (var currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (var currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          var q = delta;
          for (var k = base;; k += base) {
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            var qMinusT = q - t;
            var baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  module.exports = {
    toASCII
  };
});

// node_modules/@kamilkisiela/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string, char1, fromIndex, stopCharacterTable) {
    var len2 = string.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string, char1, char2) {
    for (var i2 = 0, len2 = string.length;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
      if (typeof item === "number") {
        ret[item] = 1;
      } else {
        var start = item[0];
        var end = item[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring = __require("querystring");
  Url.queryString = querystring;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 35)
      hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
      relative = Url.parse(relative, false, true);
    var result = this._clone();
    result.hash = relative.hash;
    if (!relative.href) {
      result._href = "";
      return result;
    }
    if (relative.slashes && !relative._protocol) {
      relative._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
      if (!slashProtocols[relative._protocol]) {
        relative._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative._protocol;
      if (!relative.host && relative._protocol !== "javascript") {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result._port = relative._port;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative._protocol) {
        relative.hostname = "";
        relative._port = -1;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host ? relative.host : result.host;
      result.hostname = relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
    } else if (relative.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  };
  var punycode = require_punycode();
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path;
    if (escape2) {
      path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p = this.pathname || "";
      var s = this.search || "";
      if (p || s) {
        return p + s;
      }
      return p == null && s ? "/" + s : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
  };
  Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source)
      return relative;
    return Url.parse(source, false, true).resolveObject(relative);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c = autoEscape[i];
    esc = encodeURIComponent(c);
    if (esc === c) {
      esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
  }
  var c;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    __require.cache.url = {
      exports: Url
    };
  };
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value = this.params[name];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name) {
      const value = this.params[name];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value) {
      this.params[name] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item of value) {
            yield [key, item];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
    static createObjectURL(blob) {
      const blobUrl = `blob:whatwgnode:${(0, crypto_1.randomUUID)()}`;
      this.blobRegistry.set(blobUrl, blob);
      return blobUrl;
    }
    static resolveObjectURL(url) {
      if (!this.blobRegistry.has(url)) {
        URL.revokeObjectURL(url);
      } else {
        this.blobRegistry.delete(url);
      }
    }
    static getBlobFromURL(url) {
      return this.blobRegistry.get(url) || (0, buffer_1.resolveObjectURL)(url);
    }
  }
  exports.PonyfillURL = PonyfillURL;
  PonyfillURL.blobRegistry = new Map;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        nodeRequest.once("response", (nodeResponse) => {
          let responseBody = nodeResponse;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
              break;
            case "x-deflate":
            case "deflate":
              responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
              break;
            case "br":
              responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
              break;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          if (responseBody === nodeResponse) {
            responseBody = nodeResponse.pipe(new stream_1.PassThrough);
            responseBody.on("pause", () => {
              nodeResponse.pause();
            });
            responseBody.on("resume", () => {
              nodeResponse.resume();
            });
            responseBody.on("close", () => {
              nodeResponse.destroy();
            });
            fetchRequest["_signal"]?.addEventListener("abort", () => {
              if (!nodeResponse.destroyed) {
                responseBody.emit("error", new AbortError_js_1.PonyfillAbortError);
              }
            });
          }
          nodeResponse.once("error", reject);
          const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = undefined;
  var http_1 = __require("http");
  var https_1 = __require("https");
  var stream_1 = __require("stream");
  var zlib_1 = __require("zlib");
  var AbortError_js_1 = require_AbortError();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  exports.fetchNodeHttp = fetchNodeHttp;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var getResponseForBlob = function(url) {
    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);
    if (!blob) {
      throw new TypeError("Invalid Blob URL");
    }
    return new Response_js_1.PonyfillResponse(blob, {
      status: 200,
      headers: {
        "content-type": blob.type,
        "content-length": blob.size.toString()
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("blob:")) {
      const response = getResponseForBlob(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = undefined;
  var fs_1 = __require("fs");
  var url_1 = __require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
  exports.fetchPonyfill = fetchPonyfill;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source, destination) {
      const buffer = this.encode(source);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      this.fatal = false;
      this.ignoreBOM = false;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
  exports.PonyfillBtoa = PonyfillBtoa;
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  var shouldSkipPonyfill = require_shouldSkipPonyfill();
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (shouldSkipPonyfill()) {
      return globalThis;
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = globalThis.WritableStream;
    ponyfills.TransformStream = globalThis.TransformStream;
    if (!ponyfills.WritableStream) {
      const streamsWeb = __require("stream/web");
      ponyfills.WritableStream = streamsWeb.WritableStream;
      ponyfills.TransformStream = streamsWeb.TransformStream;
    }
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = __require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js
var require_shouldSkipPonyfill2 = __commonJS((exports, module) => {
  var isNextJs = function() {
    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));
  };
  module.exports = function shouldSkipPonyfill() {
    if (globalThis.Deno) {
      return true;
    }
    if (process.versions.bun) {
      return true;
    }
    if (isNextJs()) {
      return true;
    }
    return false;
  };
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern2 = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Ae.test(i) || s !== n + 1 && ye.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${S(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (h) => {
      if (l < r.length && r[l].type === h)
        return r[l++].value;
    }, f = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), d = (h) => {
      let u = o(h);
      if (u !== undefined)
        return u;
      let { type: p, index: A } = r[l];
      throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`);
    }, T = () => {
      let h = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        h += u;
      return h;
    }, xe = (h) => h, L = t.encodePart || xe, I = "", U = (h) => {
      I += h;
    }, $ = () => {
      I.length && (a.push(new R(3, "", "", L(I), "", 3)), I = "");
    }, X = (h, u, p, A, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !p && g === 3) {
        U(h);
        return;
      }
      if ($(), !u && !p) {
        if (!h)
          return;
        a.push(new R(3, "", "", L(h), "", g));
        return;
      }
      let m;
      p ? p === "*" ? m = v : m = p : m = n;
      let O = 2;
      m === n ? (O = 1, m = "") : m === v && (O = 0, m = "");
      let P;
      if (u ? P = u : p && (P = c++), i.has(P))
        throw new TypeError(`Duplicate name '${P}'.`);
      i.add(P), a.push(new R(O, P, L(h), m, L(A), g));
    };
    for (;l < r.length; ) {
      let h = o("CHAR"), u = o("NAME"), p = o("REGEX");
      if (!u && !p && (p = o("ASTERISK")), u || p) {
        let g = h ?? "";
        t.prefixes.indexOf(g) === -1 && (U(g), g = ""), $();
        let m = f();
        X(g, u, p, "", m);
        continue;
      }
      let A = h ?? o("ESCAPED_CHAR");
      if (A) {
        U(A);
        continue;
      }
      if (o("OPEN")) {
        let g = T(), m = o("NAME"), O = o("REGEX");
        !m && !O && (O = o("ASTERISK"));
        let P = T();
        d("CLOSE");
        let be = f();
        X(g, m, O, P, be);
        continue;
      }
      $(), d("END");
    }
    return a;
  };
  var S = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var k = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += S(s.value) : n += `(?:${S(s.value)})${k(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${S(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${k(s.modifier)}` : n += `((?:${o})${k(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${S(s.prefix)}(${o})${S(s.suffix)})`, n += k(s.modifier);
        continue;
      }
      n += `(?:${S(s.prefix)}`, n += `((?:${o})(?:`, n += S(s.suffix), n += S(s.prefix), n += `(?:${o}))*)${S(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${S(r.endsWith)}]|\$`, c = `[${S(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : G(e);
  };
  var fe = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : y(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var y = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var he = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var G = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var de = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var pe = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var Se = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var b = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), t.protocol === undefined && (e.protocol = b(n.protocol.substring(0, n.protocol.length - 1), r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && (e.username = b(n.username, r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && t.password === undefined && (e.password = b(n.password, r)), t.protocol === undefined && t.hostname === undefined && (e.hostname = b(n.hostname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && (e.port = b(n.port, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && (e.pathname = b(n.pathname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && (e.search = b(n.search.substring(1, n.search.length), r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && t.hash === undefined && (e.hash = b(n.hash.substring(1, n.hash.length), r));
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = fe(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = b(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${k(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), f = l > 0 ? e[l - 1] : null, d = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && d && !d.prefix.length && !d.suffix.length)
        if (d.type === 3) {
          let T = d.value.length > 0 ? d.value[0] : "";
          o = a.test(T);
        } else
          o = !d.hasCustomName();
      if (!o && !s.prefix.length && f && f.type === 3) {
        let T = f.value[f.value.length - 1];
        o = t.prefixes.includes(T);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!f || f.type === 3 || f.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += k(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Pe = Object.getOwnPropertyDescriptor;
  var Re = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Oe = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ke = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of Re(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Pe(t, a)) || n.enumerable });
    return e;
  };
  var Te = (e) => ke(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Oe(Ne, { URLPattern: () => Y });
  module.exports = Te(Ne);
  var R = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Ae = /[$_\p{ID_Start}]/u;
  var ye = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var x = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var H = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #l = 0;
    #o = 0;
    #d = 0;
    #p = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#o === 0) {
            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);
            continue;
          } else if (this.#o === 2) {
            this.#u(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#d > 0)
          if (this.#A())
            this.#d -= 1;
          else
            continue;
        if (this.#T()) {
          this.#d += 1;
          continue;
        }
        switch (this.#o) {
          case 0:
            this.#P() && this.#u(1);
            break;
          case 1:
            if (this.#P()) {
              this.#C();
              let t = 7, r = 1;
              this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);
            break;
          case 3:
            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);
            break;
          case 4:
            this.#S() && this.#r(5, 1);
            break;
          case 5:
            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 6:
            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 8:
            this.#f() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");
    }
    #r(t, r) {
      switch (this.#o) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#c();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#c();
          break;
        case 4:
          this.#t.password = this.#c();
          break;
        case 5:
          this.#t.hostname = this.#c();
          break;
        case 6:
          this.#t.port = this.#c();
          break;
        case 7:
          this.#t.pathname = this.#c();
          break;
        case 8:
          this.#t.search = this.#c();
          break;
        case 9:
          this.#t.hash = this.#c();
          break;
        case 10:
          break;
      }
      this.#o !== 0 && t !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t === 9 && (this.#t.search ??= "")), this.#R(t, r);
    }
    #R(t, r) {
      this.#o = t, this.#l = this.#e + r, this.#e += r, this.#s = 0;
    }
    #b() {
      this.#e = this.#l, this.#s = 0;
    }
    #u(t) {
      this.#b(), this.#o = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #P() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #S() {
      return this.#a(this.#e, "@");
    }
    #O() {
      return this.#a(this.#e, ":");
    }
    #k() {
      return this.#a(this.#e, ":");
    }
    #x() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #f() {
      return this.#a(this.#e, "#");
    }
    #T() {
      return this.#n[this.#e].type == "OPEN";
    }
    #A() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #y() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #c() {
      let t = this.#n[this.#e], r = this.#m(this.#l).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, x), t.encodePart = y;
      let r = q(this.#c(), undefined, t);
      this.#g = N(r);
    }
  };
  var V = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    #l = false;
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new H(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of V) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, x), i.encodePart = y;
              break;
            case "username":
              Object.assign(i, x), i.encodePart = he;
              break;
            case "password":
              Object.assign(i, x), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, x), i.encodePart = G;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = de) : (Object.assign(i, x, c), i.encodePart = pe);
              break;
            case "search":
              Object.assign(i, x, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, x, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i), this.#l = this.#l || this.#s[s].some((f) => f.type === 2);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of V)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of V) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let f = l[i + 1];
            s[o] = f;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let f of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[f] < o[f])
            return -1;
          if (i[f] === o[f])
            continue;
          return 1;
        }
        return 0;
      }, c = new R(3, "", "", "", "", 3), l = new R(0, "", "", "", "", 3), s = (i, o) => {
        let f = 0;
        for (;f < Math.min(i.length, o.length); ++f) {
          let d = a(i[f], o[f]);
          if (d)
            return d;
        }
        return i.length === o.length ? 0 : a(i[f] ?? c, o[f] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
    get hasRegExpGroups() {
      return this.#l;
    }
  };
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill2 = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern2();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream2 = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = __require("stream");

  class PonyfillReadableStream {
    constructor(underlyingSource) {
      this.locked = false;
      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        let reader;
        let started = false;
        this.readable = new stream_1.Readable({
          read() {
            if (!started) {
              started = true;
              reader = underlyingSource.getReader();
            }
            reader.read().then(({ value, done }) => {
              if (done) {
                this.push(null);
              } else {
                this.push(value);
              }
            }).catch((err) => {
              this.destroy(err);
            });
          },
          destroy(err, callback) {
            reader.cancel(err).then(() => callback(err), callback);
          }
        });
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          async destroy(err, callback) {
            try {
              await underlyingSource?.cancel?.(err);
              callback(null);
            } catch (err2) {
              callback(err2);
            }
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return Promise.resolve();
    }
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          iterator.return?.();
          this.locked = false;
        },
        cancel: async (reason) => {
          await iterator.return?.(reason);
          this.locked = false;
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    async pipeTo(destination) {
      const writer = destination.getWriter();
      await writer.ready;
      for await (const chunk of this.readable) {
        await writer.write(chunk);
      }
      await writer.ready;
      return writer.close();
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils3 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise2 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise2(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise2(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise2(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadable = exports.isArrayBufferView = exports.fakePromise = exports.defaultHeadersSerializer = exports.getHeadersObj = undefined;
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob2 = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var isBlob = function(obj) {
    return obj != null && obj.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  var ReadableStream_js_1 = require_ReadableStream2();
  var utils_js_1 = require_utils3();

  class PonyfillBlob {
    constructor(blobParts, options) {
      this.blobParts = blobParts;
      this._size = null;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && isBlob(blobParts[0])) {
        return blobParts[0];
      }
    }
    arrayBuffer() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.arrayBuffer();
        }
        return (0, utils_js_1.fakePromise)(getBlobPartAsBuffer(blobPart));
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (isBlob(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    text() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          return (0, utils_js_1.fakePromise)(blobPart);
        }
        if (isBlob(blobPart)) {
          return blobPart.text();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(buf.toString(this.encoding));
      }
      return this.arrayBuffer().then((buf) => buf.toString(this.encoding));
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (isBlob(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob2();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.webkitRelativePath = "";
      this.lastModified = options?.lastModified || Date.now();
    }
  }
  exports.PonyfillFile = PonyfillFile;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData2 = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    Object.defineProperty(blob, "name", {
      configurable: true,
      enumerable: true,
      value: fileName || blob.name || name
    });
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamFromFormData = exports.PonyfillFormData = undefined;
  var ReadableStream_js_1 = require_ReadableStream2();

  class PonyfillFormData {
    constructor() {
      this.map = new Map;
    }
    append(name, value, fileName) {
      let values2 = this.map.get(name);
      if (!values2) {
        values2 = [];
        this.map.set(name, values2);
      }
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      values2.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values2 = this.map.get(name);
      return values2 ? values2[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values2] of this.map) {
        for (const value of values2) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values2 of this.map.values()) {
        for (const value of values2) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
  exports.getStreamFromFormData = getStreamFromFormData;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body2 = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (isReadableStream(bodyInit)) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  var isReadableStream = function(value) {
    return value?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = __require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob2();
  var File_js_1 = require_File2();
  var FormData_js_1 = require_FormData2();
  var ReadableStream_js_1 = require_ReadableStream2();
  var utils_js_1 = require_utils3();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      this.bodyUsed = false;
      this.contentType = null;
      this.contentLength = null;
      this._bodyFactory = () => null;
      this._generatedBody = null;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    generateBody() {
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _collectChunksFromReadable() {
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      const chunks = [];
      _body.readable.on("data", (chunk) => {
        chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    blob() {
      if (this.bodyType === BodyInitType.Blob) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      if (this._buffer) {
        const blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
      });
    }
    formData(opts) {
      if (this.bodyType === BodyInitType.FormData) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      const formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          formData.set(name, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(formData);
        });
        bb.on("error", (err = "An error occurred while parsing the form data") => {
          const errMessage = err.message || err.toString();
          reject(new TypeError(errMessage, err.cause));
        });
        _body?.readable.pipe(bb);
      });
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
          return this.bodyInit.arrayBuffer();
        }
        const bodyInitTyped = this.bodyInit;
        return bodyInitTyped.arrayBuffer().then((arrayBuffer) => Buffer.from(arrayBuffer, undefined, bodyInitTyped.size));
      }
      return this._collectChunksFromReadable().then(function concatCollectedChunksFromReadable(chunks) {
        if (chunks.length === 1) {
          return chunks[0];
        }
        return Buffer.concat(chunks);
      });
    }
    json() {
      return this.text().then(function parseTextAsJson(text) {
        return JSON.parse(text);
      });
    }
    text() {
      if (this.bodyType === BodyInitType.String) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      return this.arrayBuffer().then((buffer) => buffer.toString("utf-8"));
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers2 = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillHeaders = exports.isHeadersLike = undefined;
  var util_1 = __require("util");
  exports.isHeadersLike = isHeadersLike;

  class PonyfillHeaders {
    constructor(headersInit) {
      this.headersInit = headersInit;
      this.objectNormalizedKeysOfHeadersInit = [];
      this.objectOriginalKeysOfHeadersInit = [];
      this._setCookies = [];
    }
    _get(key) {
      const normalized = key.toLowerCase();
      if (normalized === "set-cookie") {
        return this._setCookies.join(", ");
      }
      if (this._map) {
        return this._map.get(normalized) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach(([key, value]) => {
              const normalizedKey = key.toLowerCase();
              if (normalizedKey === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(normalizedKey, value);
            });
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              if (key === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                if (normalizedKey === "set-cookie") {
                  this._setCookies.push(initValue);
                  continue;
                }
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies.push(value);
        return;
      }
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value = this._get(name);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name) {
      if (name === "set-cookie") {
        return this._setCookies.length > 0;
      }
      return !!this._get(name);
    }
    set(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [value];
        return;
      }
      this.getMap().set(key, value);
    }
    delete(name) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [];
        return;
      }
      this.getMap().delete(key);
    }
    forEach(callback) {
      this._setCookies.forEach((setCookie) => {
        callback(setCookie, "set-cookie", this);
      });
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    *keys() {
      if (this._setCookies.length) {
        yield "set-cookie";
      }
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.keys();
            return;
          }
          yield* Object.keys(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().keys();
    }
    *values() {
      yield* this._setCookies;
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.values();
            return;
          }
          yield* Object.values(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().values();
    }
    *entries() {
      yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit;
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.entries();
            return;
          }
          yield* Object.entries(this.headersInit);
          return;
        }
      }
      yield* this.getMap().entries();
    }
    getSetCookie() {
      return this._setCookies;
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this._setCookies;
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = __require("http");
  var Body_js_1 = require_Body2();
  var Headers_js_1 = require_Headers2();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    clone() {
      return new PonyfillResponse(this.body, this);
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 301) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl2 = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    curlHandle.setOpt("SSL_VERIFYPEER", false);
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    return new Promise(function promiseResolver(resolve, reject) {
      let streamResolved;
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          if (curlHandle.isOpen) {
            try {
              curlHandle.pause(CurlPause.Recv);
            } catch (e) {
              reject(e);
            }
          }
        };
      }
      curlHandle.once("end", function endListener() {
        curlHandle.close();
      });
      curlHandle.once("error", function errorListener(error) {
        if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {
          streamResolved.destroy(error);
        } else {
          if (error.message === "Operation was aborted by an application callback") {
            error.message = "The operation was aborted.";
          }
          reject(error);
        }
        curlHandle.close();
      });
      curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
        const pipedStream = stream.pipe(new stream_1.PassThrough);
        const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
          if (headerFilter && !headerFilter.startsWith("HTTP/")) {
            if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
              pipedStream.destroy();
              reject(new Error("redirect is not allowed"));
            }
            return true;
          }
          return false;
        });
        const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
        pipedStream.on("pause", () => {
          stream.pause();
        });
        pipedStream.on("resume", () => {
          stream.resume();
        });
        pipedStream.on("close", () => {
          stream.destroy();
        });
        const ponyfillResponse = new Response_js_1.PonyfillResponse(pipedStream, {
          status,
          headers: headersInit,
          url: fetchRequest.url
        });
        resolve(ponyfillResponse);
        streamResolved = pipedStream;
      });
      curlHandle.perform();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = undefined;
  var stream_1 = __require("stream");
  var Response_js_1 = require_Response2();
  var utils_js_1 = require_utils3();
  exports.fetchCurl = fetchCurl;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillAbortError = undefined;

  class PonyfillAbortError extends Error {
    constructor(reason) {
      let message = "The operation was aborted";
      if (reason) {
        message += ` reason: ${reason}`;
      }
      super(message, {
        cause: reason
      });
      this.name = "AbortError";
    }
    get reason() {
      return this.cause;
    }
  }
  exports.PonyfillAbortError = PonyfillAbortError;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request2 = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var Body_js_1 = require_Body2();
  var Headers_js_1 = require_Headers2();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this[_a] = "Request";
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.duplex = requestInit?.duplex || "half";
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (bodyInit == null && !contentLengthInHeaders) {
          this.contentLength = 0;
          this.headers.set("content-length", "0");
        }
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
    }
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return new PonyfillRequest(this);
    }
  }
  exports.PonyfillRequest = PonyfillRequest;
  _a = Symbol.toStringTag;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams2 = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value = this.params[name];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name) {
      const value = this.params[name];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value) {
      this.params[name] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item of value) {
            yield [key, item];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams2();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
    static createObjectURL(blob) {
      const blobUrl = `blob:whatwgnode:${(0, crypto_1.randomUUID)()}`;
      this.blobRegistry.set(blobUrl, blob);
      return blobUrl;
    }
    static resolveObjectURL(url) {
      if (!this.blobRegistry.has(url)) {
        URL.revokeObjectURL(url);
      } else {
        this.blobRegistry.delete(url);
      }
    }
    static getBlobFromURL(url) {
      return this.blobRegistry.get(url) || (0, buffer_1.resolveObjectURL)(url);
    }
  }
  exports.PonyfillURL = PonyfillURL;
  PonyfillURL.blobRegistry = new Map;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp2 = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        nodeRequest.once("response", (nodeResponse) => {
          let responseBody = nodeResponse;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
              break;
            case "x-deflate":
            case "deflate":
              responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
              break;
            case "br":
              responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
              break;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          if (responseBody === nodeResponse) {
            responseBody = nodeResponse.pipe(new stream_1.PassThrough);
            responseBody.on("pause", () => {
              nodeResponse.pause();
            });
            responseBody.on("resume", () => {
              nodeResponse.resume();
            });
            responseBody.on("close", () => {
              nodeResponse.destroy();
            });
            fetchRequest["_signal"]?.addEventListener("abort", () => {
              if (!nodeResponse.destroyed) {
                responseBody.emit("error", new AbortError_js_1.PonyfillAbortError);
              }
            });
          }
          nodeResponse.once("error", reject);
          const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = undefined;
  var http_1 = __require("http");
  var https_1 = __require("https");
  var stream_1 = __require("stream");
  var zlib_1 = __require("zlib");
  var AbortError_js_1 = require_AbortError2();
  var Request_js_1 = require_Request2();
  var Response_js_1 = require_Response2();
  var URL_js_1 = require_URL2();
  var utils_js_1 = require_utils3();
  exports.fetchNodeHttp = fetchNodeHttp;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch2 = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var getResponseForBlob = function(url) {
    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);
    if (!blob) {
      throw new TypeError("Invalid Blob URL");
    }
    return new Response_js_1.PonyfillResponse(blob, {
      status: 200,
      headers: {
        "content-type": blob.type,
        "content-length": blob.size.toString()
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("blob:")) {
      const response = getResponseForBlob(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = undefined;
  var fs_1 = __require("fs");
  var url_1 = __require("url");
  var fetchCurl_js_1 = require_fetchCurl2();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp2();
  var Request_js_1 = require_Request2();
  var Response_js_1 = require_Response2();
  var URL_js_1 = require_URL2();
  var utils_js_1 = require_utils3();
  var BASE64_SUFFIX = ";base64";
  exports.fetchPonyfill = fetchPonyfill;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder2 = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  var utils_js_1 = require_utils3();

  class PonyfillTextEncoder {
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source, destination) {
      const buffer = this.encode(source);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      this.fatal = false;
      this.ignoreBOM = false;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
  exports.PonyfillBtoa = PonyfillBtoa;
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch2();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers2();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body2();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request2();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response2();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream2();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File2();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData2();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob2();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder2();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL2();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams2();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill2 = __commonJS((exports, module) => {
  var shouldSkipPonyfill2 = require_shouldSkipPonyfill2();
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills2 = {};
    if (!ponyfills2.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill2();
      ponyfills2.URLPattern = urlPatternModule.URLPattern;
    }
    if (shouldSkipPonyfill2()) {
      return globalThis;
    }
    const newNodeFetch = require_cjs2();
    ponyfills2.fetch = newNodeFetch.fetch;
    ponyfills2.Request = newNodeFetch.Request;
    ponyfills2.Response = newNodeFetch.Response;
    ponyfills2.Headers = newNodeFetch.Headers;
    ponyfills2.FormData = newNodeFetch.FormData;
    ponyfills2.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills2.URL = newNodeFetch.URL;
    ponyfills2.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills2.WritableStream = globalThis.WritableStream;
    ponyfills2.TransformStream = globalThis.TransformStream;
    if (!ponyfills2.WritableStream) {
      const streamsWeb = __require("stream/web");
      ponyfills2.WritableStream = streamsWeb.WritableStream;
      ponyfills2.TransformStream = streamsWeb.TransformStream;
    }
    ponyfills2.Blob = newNodeFetch.Blob;
    ponyfills2.File = newNodeFetch.File;
    ponyfills2.crypto = globalThis.crypto;
    ponyfills2.btoa = newNodeFetch.btoa;
    ponyfills2.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills2.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills2.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills2.Request = class Request extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills2.Response = class Response extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills2.crypto) {
      const cryptoModule = __require("crypto");
      ponyfills2.crypto = cryptoModule.webcrypto;
    }
    return ponyfills2;
  };
});

// node_modules/graphql-yoga/esm/error.js
var import_graphql20 = __toESM(require_graphql2(), 1);
// node_modules/@graphql-tools/utils/esm/helpers.js
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  let name;
  if ("alias" in a) {
    name = a.alias?.value;
  }
  if (name == null && "name" in a) {
    name = a.name?.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}
var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
// node_modules/cross-inspect/esm/index.js
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatError = function(value) {
  if (value.name = "GraphQLError") {
    return value.toString();
  }
  return `${value.name}: ${value.message};\n ${value.stack}`;
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH = 3;

// node_modules/@graphql-tools/utils/esm/getArgumentValues.js
var import_graphql2 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/errors.js
var import_graphql = __toESM(require_graphql2(), 1);
var isGraphQLErrorLike = function(error) {
  return error != null && typeof error === "object" && Object.keys(error).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (import_graphql.versionInfo.major >= 17) {
    return new import_graphql.GraphQLError(message, options);
  }
  return new import_graphql.GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isPromise(value) {
  return value?.then != null;
}
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name] = defaultValue;
      } else if (import_graphql2.isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === import_graphql2.Kind.NULL;
    if (valueNode.kind === import_graphql2.Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (import_graphql2.isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && import_graphql2.isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = import_graphql2.valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${import_graphql2.print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node?.extensions);
}
// node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
var import_graphql7 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/astFromType.js
var import_graphql3 = __toESM(require_graphql2(), 1);
function astFromType(type) {
  if (import_graphql3.isNonNullType(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === import_graphql3.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql3.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if (import_graphql3.isListType(type)) {
    return {
      kind: import_graphql3.Kind.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: import_graphql3.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql3.Kind.NAME,
      value: type.name
    }
  };
}

// node_modules/@graphql-tools/utils/esm/astFromValue.js
var import_graphql5 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
var import_graphql4 = __toESM(require_graphql2(), 1);
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: import_graphql4.Kind.NULL };
  }
  if (value === undefined) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql4.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    if (value?.toJSON) {
      return astFromValueUntyped(value.toJSON());
    }
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql4.Kind.OBJECT_FIELD,
          name: { kind: import_graphql4.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql4.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql4.Kind.BOOLEAN, value };
  }
  if (typeof value === "bigint") {
    return { kind: import_graphql4.Kind.INT, value: String(value) };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: import_graphql4.Kind.INT, value: stringNum } : { kind: import_graphql4.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql4.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/@graphql-tools/utils/esm/astFromValue.js
function astFromValue(value, type) {
  if (import_graphql5.isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if (astValue?.kind === import_graphql5.Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return { kind: import_graphql5.Kind.NULL };
  }
  if (value === undefined) {
    return null;
  }
  if (import_graphql5.isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: import_graphql5.Kind.LIST, values: valuesNodes };
    }
    return astFromValue(value, itemType);
  }
  if (import_graphql5.isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: import_graphql5.Kind.OBJECT_FIELD,
          name: { kind: import_graphql5.Kind.NAME, value: field.name },
          value: fieldValue
        });
      }
    }
    return { kind: import_graphql5.Kind.OBJECT, fields: fieldNodes };
  }
  if (import_graphql5.isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (import_graphql5.isEnumType(type)) {
      return { kind: import_graphql5.Kind.ENUM, value: serialized };
    }
    if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp2.test(serialized)) {
      return { kind: import_graphql5.Kind.INT, value: serialized };
    }
    return astFromValueUntyped(serialized);
  }
  console.assert(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/@graphql-tools/utils/esm/descriptionFromObject.js
var import_graphql6 = __toESM(require_graphql2(), 1);
function getDescriptionNode(obj) {
  if (obj.astNode?.description) {
    return {
      ...obj.astNode.description,
      block: true
    };
  }
  if (obj.description) {
    return {
      kind: import_graphql6.Kind.STRING,
      value: obj.description,
      block: true
    };
  }
}

// node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === undefined) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize3(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema) {
  const rootTypes = getRootTypes(schema);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema) {
  const rootTypeMap = getRootTypeMap(schema);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema) {
  const rootTypeMap = new Map;
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema(schema, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if (import_graphql7.isSpecifiedDirective(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = import_graphql7.isSpecifiedScalarType(type);
    const isIntrospection = import_graphql7.isIntrospectionType(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if (import_graphql7.isObjectType(type)) {
      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
    } else if (import_graphql7.isInterfaceType(type)) {
      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
    } else if (import_graphql7.isUnionType(type)) {
      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
    } else if (import_graphql7.isInputObjectType(type)) {
      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
    } else if (import_graphql7.isEnumType(type)) {
      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
    } else if (import_graphql7.isScalarType(type)) {
      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: import_graphql7.Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema, pathToDirectivesInExtensions) {
  const operationTypeMap = new Map([
    ["query", undefined],
    ["mutation", undefined],
    ["subscription", undefined]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql7.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql7.Kind.SCHEMA_DEFINITION : import_graphql7.Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives
  };
  const descriptionNode = getDescriptionNode(schema);
  if (descriptionNode) {
    schemaNode.description = descriptionNode;
  }
  return schemaNode;
}
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.DIRECTIVE_DEFINITION,
    description: getDescriptionNode(directive),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: directive.name
    },
    arguments: directive.args?.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: directive.locations?.map((location) => ({
      kind: import_graphql7.Kind.NAME,
      value: location
    })) || []
  };
}
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = entity.astNode?.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = directives.filter((directive) => directive.name.value === "deprecated")?.[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(arg),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    defaultValue: arg.defaultValue !== undefined ? astFromValue(arg.defaultValue, arg.type) ?? undefined : undefined,
    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
  const node = {
    kind: import_graphql7.Kind.INTERFACE_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.UNION_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.ENUM_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : type.astNode?.directives || [];
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql7.Kind.SCALAR_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    directives
  };
}
function astFromField(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.FIELD_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
    defaultValue: astFromValue(field.defaultValue, field.type) ?? undefined
  };
}
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.ENUM_VALUE_DEFINITION,
    description: getDescriptionNode(value),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: value.name
    },
    directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, import_graphql7.GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== undefined) {
        const value = astFromValue(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql7.Kind.ARGUMENT,
            name: {
              kind: import_graphql7.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql7.Kind.ARGUMENT,
          name: {
            kind: import_graphql7.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql7.Kind.DIRECTIVE,
    name: {
      kind: import_graphql7.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema?.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}
// node_modules/@graphql-tools/utils/esm/comments.js
var import_graphql8 = __toESM(require_graphql2(), 1);
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  const entityName = node.name?.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys = [entity];
  if (field) {
    keys.push(field);
    if (argument) {
      keys.push(argument);
    }
  }
  const path = keys.join(".");
  if (!commentsRegistry[path]) {
    commentsRegistry[path] = [];
  }
  commentsRegistry[path].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
var join = function(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
};
var hasMultilineItems = function(maybeArray) {
  return maybeArray?.some((str) => str.includes("\n")) ?? false;
};
var addDescription = function(cb) {
  return (node, _key, _parent, path, ancestors) => {
    const keys = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, parent?.name?.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
  };
};
var indent = function(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
};
var block = function(array) {
  return array && array.length !== 0 ? `{\n${indent(join(array, "\n"))}\n}` : "";
};
var wrap = function(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
};
var printBlockString = function(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "\t") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""\n${isDescription ? escaped : indent(escaped)}\n"""`;
};
function printWithComments(ast) {
  return import_graphql8.visit(ast, printDocASTReducerWithComments);
}
var isFieldDefinitionNode = function(node) {
  return node.kind === "FieldDefinition";
};
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== undefined) {
    return dedentBlockStringValue(`\n${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql8.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : undefined;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1;i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1;i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "\t")) {
    i++;
  }
  return i;
};
var isBlank = function(str) {
  return leadingWhitespace(str) === str.length;
};
var MAX_LINE_LENGTH = 80;
var commentsRegistry = {};
var printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
// node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));

// node_modules/@graphql-tools/utils/esm/mapSchema.js
var import_graphql13 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
var import_graphql9 = __toESM(require_graphql2(), 1);
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if (import_graphql9.isObjectType(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}

// node_modules/@graphql-tools/utils/esm/rewire.js
var import_graphql11 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/stub.js
var import_graphql10 = __toESM(require_graphql2(), 1);
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case import_graphql10.GraphQLInt.name:
      return import_graphql10.GraphQLInt;
    case import_graphql10.GraphQLFloat.name:
      return import_graphql10.GraphQLFloat;
    case import_graphql10.GraphQLString.name:
      return import_graphql10.GraphQLString;
    case import_graphql10.GraphQLBoolean.name:
      return import_graphql10.GraphQLBoolean;
    case import_graphql10.GraphQLID.name:
      return import_graphql10.GraphQLID;
    default:
      return type;
  }
}

// node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if (import_graphql11.isSpecifiedDirective(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql11.GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if (import_graphql11.isObjectType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields),
        interfaces: () => rewireNamedTypes(config.interfaces)
      };
      return new import_graphql11.GraphQLObjectType(newConfig);
    } else if (import_graphql11.isInterfaceType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
      }
      return new import_graphql11.GraphQLInterfaceType(newConfig);
    } else if (import_graphql11.isUnionType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        types: () => rewireNamedTypes(config.types)
      };
      return new import_graphql11.GraphQLUnionType(newConfig);
    } else if (import_graphql11.isInputObjectType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireInputFields(config.fields)
      };
      return new import_graphql11.GraphQLInputObjectType(newConfig);
    } else if (import_graphql11.isEnumType(type)) {
      const enumConfig = type.toConfig();
      return new import_graphql11.GraphQLEnumType(enumConfig);
    } else if (import_graphql11.isScalarType(type)) {
      if (import_graphql11.isSpecifiedScalarType(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new import_graphql11.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if (import_graphql11.isListType(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql11.GraphQLList(rewiredType) : null;
    } else if (import_graphql11.isNonNullType(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql11.GraphQLNonNull(rewiredType) : null;
    } else if (import_graphql11.isNamedType(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === undefined) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}

// node_modules/@graphql-tools/utils/esm/transformInputValue.js
var import_graphql12 = __toESM(require_graphql2(), 1);
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = import_graphql12.getNullableType(type);
  if (import_graphql12.isLeafType(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if (import_graphql12.isListType(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if (import_graphql12.isInputObjectType(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.serialize(v);
    } catch {
      return v;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.parseValue(v);
    } catch {
      return v;
    }
  });
}

// node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => import_graphql13.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !import_graphql13.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new import_graphql13.GraphQLSchema({
    ...schema.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
var mapTypes = function(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === undefined) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
};
var mapEnumValues = function(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config = type.toConfig();
      const originalEnumValueConfigMap = config.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
        if (mappedEnumValue === undefined) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new import_graphql13.GraphQLEnumType({
        ...config,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => import_graphql13.isEnumType(type));
};
var mapDefaultValues = function(originalTypeMap, schema, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === undefined) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === undefined) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
};
var getNewType = function(newTypeMap, type) {
  if (import_graphql13.isListType(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql13.GraphQLList(newType) : null;
  } else if (import_graphql13.isNonNullType(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql13.GraphQLNonNull(newType) : null;
  } else if (import_graphql13.isNamedType(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
};
var mapFields = function(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!import_graphql13.isObjectType(originalType) && !import_graphql13.isInterfaceType(originalType) && !import_graphql13.isInputObjectType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === undefined) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if (import_graphql13.isObjectType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else if (import_graphql13.isInterfaceType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
};
var mapArguments = function(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!import_graphql13.isObjectType(originalType) && !import_graphql13.isInterfaceType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === undefined) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if (import_graphql13.isObjectType(originalType)) {
        newTypeMap[typeName] = new import_graphql13.GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      } else if (import_graphql13.isInterfaceType(originalType)) {
        newTypeMap[typeName] = new import_graphql13.GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql13.GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
};
var mapDirectives = function(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === undefined) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
};
var getTypeSpecifiers = function(schema, typeName) {
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if (import_graphql13.isObjectType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === schema.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === schema.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === schema.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if (import_graphql13.isInputObjectType(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if (import_graphql13.isInterfaceType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if (import_graphql13.isUnionType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if (import_graphql13.isEnumType(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if (import_graphql13.isScalarType(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
};
var getTypeMapper = function(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
};
var getFieldSpecifiers = function(schema, typeName) {
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if (import_graphql13.isObjectType(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === schema.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === schema.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === schema.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if (import_graphql13.isInterfaceType(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if (import_graphql13.isInputObjectType(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
};
var getFieldMapper = function(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper ?? null;
};
var getArgumentMapper = function(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
};
var getDirectiveMapper = function(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
};
var getEnumValueMapper = function(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
};
function correctASTNodes(type) {
  if (import_graphql13.isObjectType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql13.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.OBJECT_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new import_graphql13.GraphQLObjectType(config);
  } else if (import_graphql13.isInterfaceType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql13.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.INTERFACE_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new import_graphql13.GraphQLInterfaceType(config);
  } else if (import_graphql13.isInputObjectType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql13.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new import_graphql13.GraphQLInputObjectType(config);
  } else if (import_graphql13.isEnumType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const values = [];
      for (const enumKey in config.values) {
        const enumValueConfig = config.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        values
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        values: undefined
      }));
    }
    return new import_graphql13.GraphQLEnumType(config);
  } else {
    return type;
  }
}
// node_modules/@graphql-tools/utils/esm/heal.js
var import_graphql14 = __toESM(require_graphql2(), 1);
function healSchema(schema) {
  healTypes(schema.getTypeMap(), schema.getDirectives());
  return schema;
}
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if (import_graphql14.isObjectType(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if (import_graphql14.isInterfaceType(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if (import_graphql14.isUnionType(type)) {
      healUnderlyingTypes(type);
      return;
    } else if (import_graphql14.isInputObjectType(type)) {
      healInputFields(type);
      return;
    } else if (import_graphql14.isLeafType(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if (import_graphql14.isListType(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql14.GraphQLList(healedType) : null;
    } else if (import_graphql14.isNonNullType(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql14.GraphQLNonNull(healedType) : null;
    } else if (import_graphql14.isNamedType(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}
// node_modules/@graphql-tools/utils/esm/forEachField.js
var import_graphql15 = __toESM(require_graphql2(), 1);
function forEachField(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!import_graphql15.getNamedType(type).name.startsWith("__") && import_graphql15.isObjectType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn(field, typeName, fieldName);
      }
    }
  }
}
// node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
var import_graphql16 = __toESM(require_graphql2(), 1);
function forEachDefaultValue(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!import_graphql16.getNamedType(type).name.startsWith("__")) {
      if (import_graphql16.isObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn(arg.type, arg.defaultValue);
          }
        }
      } else if (import_graphql16.isInputObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn(field.type, field.defaultValue);
        }
      }
    }
  }
}
// node_modules/@graphql-tools/utils/esm/mergeDeep.js
function mergeDeep(sources, respectPrototype = false, respectArrays = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype, respectArrays);
          }
        } else if (respectArrays && Array.isArray(output[key])) {
          if (Array.isArray(source[key])) {
            output[key].push(...source[key]);
          } else {
            output[key].push(source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    } else if (respectArrays && Array.isArray(target)) {
      if (Array.isArray(source)) {
        target.push(...source);
      } else {
        target.push(source);
      }
    } else if (respectArrays && Array.isArray(source)) {
      return [target, ...source];
    }
  }
  return output;
}
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
// node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, onNext, onError, onEnd) {
  let $return;
  let abruptClose;
  let onEndWithValue;
  if (onEnd) {
    onEndWithValue = (value) => {
      const onEnd$ = onEnd();
      return isPromise(onEnd$) ? onEnd$.then(() => value) : value;
    };
  }
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    if (result.done) {
      return onEndWithValue ? onEndWithValue(result) : result;
    }
    return asyncMapValue(result.value, onNext).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (onError) {
    const reject = onError;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
      return onEndWithValue ? res$.then(onEndWithValue) : res$;
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
};
var iteratorResult = function(value) {
  return { value, done: false };
};
// node_modules/@graphql-tools/utils/esm/collectFields.js
var import_graphql18 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
}

// node_modules/@graphql-tools/utils/esm/directives.js
var import_graphql17 = __toESM(require_graphql2(), 1);
var GraphQLDeferDirective = new import_graphql17.GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [import_graphql17.DirectiveLocation.FRAGMENT_SPREAD, import_graphql17.DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new import_graphql17.GraphQLNonNull(import_graphql17.GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: import_graphql17.GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new import_graphql17.GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [import_graphql17.DirectiveLocation.FIELD],
  args: {
    if: {
      type: new import_graphql17.GraphQLNonNull(import_graphql17.GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: import_graphql17.GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: import_graphql17.GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl = function(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case import_graphql18.Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey(selection), selection);
        break;
      }
      case import_graphql18.Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case import_graphql18.Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode(variableValues, node) {
  const skip = import_graphql18.getDirectiveValues(import_graphql18.GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = import_graphql18.getDirectiveValues(import_graphql18.GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = import_graphql18.typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (import_graphql18.isAbstractType(conditionalType)) {
    const possibleTypes = schema.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = import_graphql18.getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});
// node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}
// node_modules/@graphql-tools/utils/esm/isDocumentNode.js
var import_graphql19 = __toESM(require_graphql2(), 1);
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql19.Kind.DOCUMENT;
}
// node_modules/@graphql-tools/utils/esm/Path.js
function addPath(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}
// node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && "errors" in obj;
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof import_graphql20.GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof import_graphql20.GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function isAbortError(error) {
  return typeof error === "object" && error?.constructor?.name === "DOMException" && error.name === "AbortError";
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors4 = new Set;
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors4.add(handledError);
      }
    }
  } else if (isAbortError(error)) {
    logger.debug("Request aborted");
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors4.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors4.add(error);
  } else if (error instanceof Error) {
    errors4.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors4.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors4.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors4.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors4);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if ("extensions" in result && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if ("errors" in result && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.2.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.2.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || request.url.endsWith(`${config.graphqlEndpoint}/`) || url.pathname === config.graphqlEndpoint || url.pathname === `${config.graphqlEndpoint}/` || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// node_modules/graphql-yoga/esm/plugins/use-schema.js
var import_graphql21 = __toESM(require_graphql2(), 1);
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (import_graphql21.isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema = schemaByRequest.get(context.request);
      if (schema == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema);
    }
  };
};

// node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
var import_graphql22 = __toESM(require_graphql2(), 1);
function assertResolversPresent(schema, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !import_graphql22.isScalarType(import_graphql22.getNamedType(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
var expectResolver = function(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
};

// node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
var import_graphql23 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  mapSchema(schema, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return;
    }
  });
}

// node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces(schema, resolvers) {
  const extendedResolvers = {};
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers[iFace.name]) {
          for (const fieldName in resolvers[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}

// node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
  for (const typeName in resolvers) {
    const resolverValue = resolvers[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema.getType(typeName);
    if (type == null) {
      const msg = `"${typeName}" defined in resolvers, but not in schema`;
      if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "error") {
        if (requireResolversToMatchSchema === "warn") {
          console.warn(msg);
        }
        continue;
      }
      throw new Error(msg);
    } else if (import_graphql23.isSpecifiedScalarType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (import_graphql23.isEnumType(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (import_graphql23.isUnionType(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (import_graphql23.isObjectType(type) || import_graphql23.isInterfaceType(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields2 = type.getFields();
          const field = fields2[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              const msg = `${typeName}.${fieldName} defined in resolvers, but not in schema`;
              if (requireResolversToMatchSchema === "error") {
                throw new Error(msg);
              } else {
                console.error(msg);
              }
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
  }
  return schema;
}
var addResolversToExistingSchema = function(schema, resolvers, defaultFieldResolver) {
  const typeMap = schema.getTypeMap();
  for (const typeName in resolvers) {
    const type = schema.getType(typeName);
    const resolverValue = resolvers[typeName];
    if (import_graphql23.isScalarType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: resolverValue?.astNode?.description ?? type.astNode.description,
            directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (import_graphql23.isEnumType(type)) {
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config.astNode != null) {
          config.astNode = {
            ...config.astNode,
            description: resolverValue?.astNode?.description ?? config.astNode.description,
            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql23.GraphQLEnumType(config);
    } else if (import_graphql23.isUnionType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if (import_graphql23.isObjectType(type) || import_graphql23.isInterfaceType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields2 = type.getFields();
        const field = fields2[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema, serializeInputValue);
  healSchema(schema);
  forEachDefaultValue(schema, parseInputValue);
  if (defaultFieldResolver != null) {
    forEachField(schema, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver;
      }
    });
  }
  return schema;
};
var createNewSchemaWithResolvers = function(schema, resolvers, defaultFieldResolver) {
  schema = mapSchema(schema, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      const config = type.toConfig();
      const resolverValue = resolvers[type.name];
      if (!import_graphql23.isSpecifiedScalarType(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: resolverValue?.astNode?.description ?? config.astNode.description,
              directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql23.GraphQLScalarType(config);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: resolverValue?.astNode?.description ?? config.astNode.description,
              directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql23.GraphQLEnumType(config);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql23.GraphQLUnionType(config);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql23.GraphQLObjectType(config);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql23.GraphQLInterfaceType(config);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver != null) {
    schema = mapSchema(schema, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
      })
    });
  }
  return schema;
};
var setFieldProperties = function(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
};

// node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
var import_graphql34 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers = new Array;
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers, true);
  if (options?.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments(args1, args2, config) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome), config);
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}
var deduplicateArguments = function(args, config) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!config?.reverseArguments) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
};

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
var directiveAlreadyExists = function(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
};
var isRepeatableDirective = function(directive, directives3) {
  return !!directives3?.[directive.name.value]?.repeatable;
};
var nameAlreadyExists = function(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
};
var mergeArguments2 = function(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
};
var deduplicateDirectives = function(directives3, definitions) {
  return directives3.map((directive, i, all) => {
    const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
    if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments2(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
};
function mergeDirectives(d1 = [], d2 = [], config, directives3) {
  const reverseOrder = config && config.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = deduplicateDirectives([...asNext], directives3);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives3)) {
      const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments2(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    return {
      ...node,
      arguments: deduplicateLists(existingNode.arguments || [], node.arguments || [], (arg, existingArgs) => !nameAlreadyExists(arg.name, existingArgs.map((a) => a.name))),
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
var deduplicateLists = function(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
};

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues(first, second, config, directives4) {
  if (config?.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = new Map;
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives4);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
var import_graphql24 = __toESM(require_graphql2(), 1);
function mergeEnum(e1, e2, config, directives5) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: config?.convertExtensions || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config, directives5),
      values: mergeEnumValues(e1.values, e2.values, config)
    };
  }
  return config?.convertExtensions ? {
    ...e1,
    kind: import_graphql24.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
var import_graphql25 = __toESM(require_graphql2(), 1);
function isStringTypes(types2) {
  return typeof types2 === "string";
}
function isSourceTypes(types2) {
  return types2 instanceof import_graphql25.Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === import_graphql25.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== import_graphql25.Kind.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === import_graphql25.Kind.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === import_graphql25.Kind.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
var fieldAlreadyExists = function(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
};
function mergeFields(type, f1, f2, config, directives6) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists(result, field);
      if (existing && !config?.ignoreFieldConflicts) {
        const newField = config?.onFieldTypeConflict && config.onFieldTypeConflict(existing, field, type, config?.throwOnConflict) || preventConflicts(type, existing, field, config?.throwOnConflict);
        newField.arguments = mergeArguments(field["arguments"] || [], existing["arguments"] || [], config);
        newField.directives = mergeDirectives(field.directives, existing.directives, config, directives6);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  if (config && config.exclusions) {
    const exclusions = config.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
var preventConflicts = function(type, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType) {
    const t1 = extractType(a.type);
    const t2 = extractType(b.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
    if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode(b.type) && !isNonNullTypeNode(a.type)) {
    a.type = b.type;
  }
  return a;
};
var safeChangeForFieldType = function(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
};

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
var import_graphql26 = __toESM(require_graphql2(), 1);
function mergeInputType(node, existingNode, config, directives7) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives7)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql26.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
var import_graphql27 = __toESM(require_graphql2(), 1);

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
var alreadyExists = function(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
};
function mergeNamedTypeArray(first = [], second = [], config = {}) {
  const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
function mergeInterface(node, existingNode, config, directives8) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives8),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config) : undefined
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql27.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var import_graphql32 = __toESM(require_graphql2(), 1);
var ast = __toESM(require_ast(), 1);

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
var import_graphql28 = __toESM(require_graphql2(), 1);
function mergeScalar(node, existingNode, config, directives9) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: config?.convertExtensions || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config, directives9)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql28.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
var import_graphql29 = __toESM(require_graphql2(), 1);
var mergeOperationTypes = function(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
};
function mergeSchemaDefs(node, existingNode, config, directives10) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql29.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql29.Kind.SCHEMA_DEFINITION ? import_graphql29.Kind.SCHEMA_DEFINITION : import_graphql29.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config, directives10),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql29.Kind.SCHEMA_DEFINITION
  } : node;
}
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
var import_graphql30 = __toESM(require_graphql2(), 1);
function mergeType(node, existingNode, config, directives11) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives11),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql30.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
var import_graphql31 = __toESM(require_graphql2(), 1);
function mergeUnion(first, second, config, directives12) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives(first.directives, second.directives, config, directives12),
      kind: config?.convertExtensions || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql31.Kind.UNION_TYPE_DEFINITION : import_graphql31.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config)
    };
  }
  return config?.convertExtensions ? {
    ...first,
    kind: import_graphql31.Kind.UNION_TYPE_DEFINITION
  } : first;
}

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config, directives13 = {}) {
  const mergedResultMap = directives13;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = nodeDefinition.name?.value;
      if (config?.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (config?.exclusions?.includes(name + ".*") || config?.exclusions?.includes(name)) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql32.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql32.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql32.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.UNION_TYPE_DEFINITION:
          case import_graphql32.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql32.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql32.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql32.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config, directives13);
            break;
          case import_graphql32.Kind.DIRECTIVE_DEFINITION:
            if (mergedResultMap[name]) {
              const isInheritedFromPrototype = name in {};
              if (isInheritedFromPrototype) {
                if (!ast.isNode(mergedResultMap[name])) {
                  mergedResultMap[name] = undefined;
                }
              }
            }
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql32.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql32.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);
    }
  }
  return mergedResultMap;
}
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
var import_graphql33 = __toESM(require_graphql2(), 1);
function mergeTypeDefs(typeSource, config) {
  resetComments();
  const doc = {
    kind: import_graphql33.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config
    })
  };
  let result;
  if (config?.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
var visitTypeSources = function(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type2 of typeSource) {
        visitTypeSources(type2, options, allDirectives, allNodes, visitedTypeSources);
      }
    } else if (import_graphql33.isSchema(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = import_graphql33.parse(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && import_graphql33.isDefinitionNode(typeSource)) {
      if (typeSource.kind === import_graphql33.Kind.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes };
};
function mergeGraphQLTypes(typeSource, config) {
  resetComments();
  const { allDirectives, allNodes } = visitTypeSources(typeSource, config);
  const mergedDirectives = mergeGraphQLNodes(allDirectives, config);
  const mergedNodes = mergeGraphQLNodes(allNodes, config, mergedDirectives);
  if (config?.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: import_graphql33.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql33.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql33.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if (config?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol]?.operationTypes?.length) {
    mergedNodes[schemaDefSymbol] = {
      kind: import_graphql33.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql33.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql33.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql33.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config?.sort) {
    const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => sortFn(a.name?.value, b.name?.value));
  }
  return mergedNodeDefinitions;
}

// node_modules/@graphql-tools/merge/esm/extensions.js
function mergeExtensions(extensions) {
  return mergeDeep(extensions, false, true);
}
var applyExtensionObject = function(obj, extensions) {
  if (!obj) {
    return;
  }
  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}], false, true);
};
function applyExtensions(schema, extensions) {
  applyExtensionObject(schema, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type2 = schema.getType(typeName);
    if (type2) {
      applyExtensionObject(type2, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type2.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema;
}

// node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs) {
    throw new Error("Must provide typeDefs");
  }
  let schema;
  if (import_graphql34.isSchema(typeDefs)) {
    schema = typeDefs;
  } else if (otherOptions?.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema = import_graphql34.buildSchema(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, otherOptions);
    schema = import_graphql34.buildASTSchema(mergedTypeDefs, otherOptions);
  }
  schema = addResolversToSchema({
    schema,
    resolvers: mergeResolvers(resolvers),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema, schemaExtensions);
  }
  return schema;
}

// node_modules/graphql-yoga/esm/schema.js
function createSchema(opts) {
  return makeExecutableSchema(opts);
}

// node_modules/graphql-yoga/esm/server.js
var import_graphql40 = __toESM(require_graphql2(), 1);

// node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
};
function mapAsyncIterator3(source, mapper) {
  const iterator = source[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: undefined, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
var getExecuteArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
};
function isAsyncIterable3(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable3(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source, onFinal) {
  const iterator = source[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source, onError) {
  const iterator = source[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins }) {
  let schema2 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate = () => throwEngineFunctionError("validate");
  const execute = () => throwEngineFunctionError("execute");
  const subscribe = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema2 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema2,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (let i = 0;i < plugins.length; i++) {
    const plugin = plugins[i];
    const pluginsToAdd = [];
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        pluginsToAdd.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
    pluginsToAdd.length && plugins.splice(i + 1, 0, ...pluginsToAdd);
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema3, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema3,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema3, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable3(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute);
  initDone = true;
  if (schema2) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema2,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema2;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// node_modules/@envelop/core/esm/create.js
var notEmpty = function(value) {
  return value != null;
};
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError(error, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError(error, message)) });
  }
};

// node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// node_modules/@graphql-tools/executor/esm/execution/execute.js
var import_graphql36 = __toESM(require_graphql2(), 1);
var import_value_or_promise = __toESM(require_main(), 1);

// node_modules/@graphql-tools/executor/esm/execution/coerceError.js
function coerceError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "object" && error != null) {
    if ("message" in error && typeof error.message === "string") {
      let errorOptions;
      if ("cause" in error) {
        errorOptions = { cause: error.cause };
      }
      const coercedError = new Error(error.message, errorOptions);
      if ("stack" in error && typeof error.stack === "string") {
        coercedError.stack = error.stack;
      }
      if ("name" in error && typeof error.name === "string") {
        coercedError.name = error.name;
      }
      return coercedError;
    }
  }
  return new Error(String(error));
}

// node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      reject(signal.reason);
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// node_modules/@graphql-tools/executor/esm/execution/values.js
var import_graphql35 = __toESM(require_graphql2(), 1);
function getVariableValues(schema2, varDefNodes, inputs, options) {
  const errors4 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema2, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors4.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors4.push(error);
    });
    if (errors4.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors4.push(error);
  }
  return { errors: errors4 };
}
var coerceVariableValues = function(schema2, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = import_graphql35.typeFromAST(schema2, varDefNode.type);
    if (!import_graphql35.isInputType(varType)) {
      const varTypeStr = import_graphql35.print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = import_graphql35.valueFromAST(varDefNode.defaultValue, varType);
      } else if (import_graphql35.isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && import_graphql35.isNonNullType(varType)) {
      const varTypeStr = inspect(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = import_graphql35.coerceInputValue(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error.originalError
      }));
    });
  }
  return coercedValues;
};

// node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  if (exeContext.signal?.aborted) {
    throw exeContext.signal.reason;
  }
  const result = new import_value_or_promise.ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }).resolve();
  return result;
};
var buildResponse = function(data, errors4) {
  return errors4.length === 0 ? { data } : { errors: errors4, data };
};
function buildExecutionContext(args) {
  const { schema: schema2, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  import_graphql36.assertValidSchema(schema2);
  const fragments = getFragmentsFromDocument(document);
  let operation;
  for (const definition of document.definitions) {
    switch (definition.kind) {
      case import_graphql36.Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition;
        } else if (definition.name?.value === operationName) {
          operation = definition;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues(schema2, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema2,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver,
    typeResolver: typeResolver ?? defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema2, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema2, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const path = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields5) {
  return promiseReduce(fields5, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    return new import_value_or_promise.ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path, fields5, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields5) {
      if (exeContext.signal?.aborted) {
        throw exeContext.signal.reason;
      }
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise(completed)) {
      return completed.then(undefined, (rawError) => {
        rawError = coerceError(rawError);
        const error = import_graphql36.locatedError(rawError, fieldNodes, pathToArray(path));
        const handledError = handleFieldError(error, returnType, errors4);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = import_graphql36.locatedError(coercedError, fieldNodes, pathToArray(path));
    const handledError = handleFieldError(error, returnType, errors4);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error, returnType, errors4) {
  if (import_graphql36.isNonNullType(returnType)) {
    throw error;
  }
  errors4.push(error);
  return null;
};
var completeValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (import_graphql36.isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (import_graphql36.isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (import_graphql36.isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (import_graphql36.isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (import_graphql36.isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = import_graphql36.getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
  });
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath(path, index, undefined);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = import_graphql36.locatedError(coercedError, fieldNodes, pathToArray(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors4));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath(path, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        rawError = coerceError(rawError);
        const error = import_graphql36.locatedError(rawError, fieldNodes, pathToArray(itemPath));
        const handledError = handleFieldError(error, itemType, errors4);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = import_graphql36.locatedError(coercedError, fieldNodes, pathToArray(itemPath));
    const handledError = handleFieldError(error, itemType, errors4);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof import_graphql36.GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to ` + `return non-nullable value, returned: ${inspect(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (import_graphql36.isObjectType(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!import_graphql36.isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields2(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload))), (error) => {
    const wrappedError = createGraphQLError(error.message, {
      originalError: error,
      nodes: [exeContext.operation]
    });
    throw wrappedError;
  }));
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise(eventStream)) {
      return eventStream.then(undefined, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema2, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema2.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef(schema2, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise(result)) {
      return result.then(assertEventStream).then(undefined, (error) => {
        throw import_graphql36.locatedError(error, fieldNodes, pathToArray(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error) {
    throw import_graphql36.locatedError(error, fieldNodes, pathToArray(path));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields5, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields5, asyncPayloadRecord);
    if (isPromise(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          rawError = coerceError(rawError);
          const error = import_graphql36.locatedError(rawError, fieldNodes, pathToArray(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = import_graphql36.locatedError(coercedError, fieldNodes, pathToArray(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item = value;
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = import_graphql36.locatedError(coercedError, fieldNodes, pathToArray(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error = import_graphql36.locatedError(rawError, fieldNodes, pathToArray(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = import_graphql36.locatedError(rawError, fieldNodes, pathToArray(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath(path, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  const abortPromise = new Promise((_, reject) => {
    exeContext.signal?.addEventListener("abort", () => {
      isDone = true;
      reject(exeContext.signal?.reason);
    });
  });
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race([
      abortPromise,
      ...Array.from(exeContext.subsequentPayloads).map((p) => p.promise)
    ]);
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef(schema2, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === import_graphql36.SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return import_graphql36.SchemaMetaFieldDef;
  } else if (fieldName === import_graphql36.TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return import_graphql36.TypeMetaFieldDef;
  } else if (fieldName === import_graphql36.TypeNameMetaFieldDef.name) {
    return import_graphql36.TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document) {
  const fragments = Object.create(null);
  for (const definition of document.definitions) {
    if (definition.kind === import_graphql36.Kind.FRAGMENT_DEFINITION) {
      fragments[definition.name.value] = definition;
    }
  }
  return fragments;
});
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type2 = possibleTypes[i];
    if (type2.isTypeOf) {
      const isTypeOfResult = type2.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type2.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source, args, contextValue, info) {
  if (isObjectLike(source) || typeof source === "function") {
    const property = source[info.fieldName];
    if (typeof property === "function") {
      return source[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
var import_graphql37 = __toESM(require_graphql2(), 1);
var import_value_or_promise2 = __toESM(require_main(), 1);
function normalizedExecutor(args) {
  const operationAST = import_graphql37.getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe(args);
  }
  return new import_value_or_promise2.ValueOrPromise(() => execute(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result);
    }
    return result;
  }).resolve();
}

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var shouldSkipPonyfill = require_shouldSkipPonyfill();
var ponyfills = createNodePonyfill();
if (!shouldSkipPonyfill()) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || __require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill2 = {};
__export(exports_node_ponyfill2, {
  fetch: () => {
    {
      return $fetch2;
    }
  },
  crypto: () => {
    {
      return $crypto2;
    }
  },
  createFetch: () => {
    {
      return $createFetch2;
    }
  },
  btoa: () => {
    {
      return $btoa2;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream2;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams2;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern2;
    }
  },
  URL: () => {
    {
      return $URL2;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream2;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder2;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder2;
    }
  },
  Response: () => {
    {
      return $Response2;
    }
  },
  Request: () => {
    {
      return $Request2;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream2;
    }
  },
  Headers: () => {
    {
      return $Headers2;
    }
  },
  FormData: () => {
    {
      return $FormData2;
    }
  },
  File: () => {
    {
      return $File2;
    }
  },
  Blob: () => {
    {
      return $Blob2;
    }
  }
});
var createNodePonyfill2 = require_create_node_ponyfill2();
var shouldSkipPonyfill2 = require_shouldSkipPonyfill2();
var ponyfills2 = createNodePonyfill2();
if (!shouldSkipPonyfill2()) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || __require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch2 = ponyfills2.fetch;
var $Headers2 = ponyfills2.Headers;
var $Request2 = ponyfills2.Request;
var $Response2 = ponyfills2.Response;
var $FormData2 = ponyfills2.FormData;
var $ReadableStream2 = ponyfills2.ReadableStream;
var $WritableStream2 = ponyfills2.WritableStream;
var $TransformStream2 = ponyfills2.TransformStream;
var $Blob2 = ponyfills2.Blob;
var $File2 = ponyfills2.File;
var $crypto2 = ponyfills2.crypto;
var $btoa2 = ponyfills2.btoa;
var $TextEncoder2 = ponyfills2.TextEncoder;
var $TextDecoder2 = ponyfills2.TextDecoder;
var $URLPattern2 = ponyfills2.URLPattern;
var $URL2 = ponyfills2.URL;
var $URLSearchParams2 = ponyfills2.URLSearchParams;
var $createFetch2 = createNodePonyfill2;

// node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable4(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable4(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL2(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  let signal;
  const nodeResponse = nodeRequestResponseMap.get(nodeRequest);
  nodeRequestResponseMap.delete(nodeRequest);
  if (nodeResponse?.once) {
    let sendAbortSignal;
    if (RequestCtor !== globalThis.Request) {
      signal = new ServerAdapterRequestAbortSignal;
      sendAbortSignal = () => signal.sendAbort();
    } else {
      const controller = new AbortController;
      signal = controller.signal;
      sendAbortSignal = () => controller.abort();
    }
    const closeEventListener = () => {
      if (signal && !signal.aborted) {
        rawRequest.aborted = true;
        sendAbortSignal();
      }
    };
    nodeResponse.once("error", closeEventListener);
    nodeResponse.once("close", closeEventListener);
    nodeResponse.once("finish", () => {
      nodeResponse.removeListener("close", closeEventListener);
    });
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  if (globalThis.process?.versions?.bun && isReadable(rawRequest)) {
    if (!bunNodeCompatModeWarned) {
      bunNodeCompatModeWarned = true;
      console.warn(`You use Bun Node compatibility mode, which is not recommended!
It will affect your performance. Please check our Bun integration recipe, and avoid using 'http' for your server implementation.`);
    }
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      duplex: "half",
      body: new ReadableStream({
        start(controller) {
          rawRequest.on("data", (chunk) => {
            controller.enqueue(chunk);
          });
          rawRequest.on("error", (e) => {
            controller.error(e);
          });
          rawRequest.on("end", () => {
            controller.close();
          });
        },
        cancel(e) {
          rawRequest.destroy(e);
        }
      }),
      signal
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest,
    duplex: "half",
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  let setCookiesSet = false;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      if (setCookiesSet) {
        return;
      }
      setCookiesSet = true;
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable4(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source) => {
    const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise2(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise2(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error, ResponseCtor) {
  return new ResponseCtor(error.stack || error.message || error.toString(), {
    status: error.status || 500
  });
}
function isolateObject(originalCtx, waitUntilPromises) {
  if (originalCtx == null) {
    return {};
  }
  const extraProps = {};
  const deletedProps = new Set;
  return new Proxy(originalCtx, {
    get(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return function waitUntil(promise) {
          waitUntilPromises.push(promise.catch((err) => console.error(err)));
        };
      }
      const extraPropVal = extraProps[prop];
      if (extraPropVal != null) {
        if (typeof extraPropVal === "function") {
          return extraPropVal.bind(extraProps);
        }
        return extraPropVal;
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return originalCtx2[prop];
    },
    set(_originalCtx, prop, value) {
      extraProps[prop] = value;
      return true;
    },
    has(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return true;
      }
      if (deletedProps.has(prop)) {
        return false;
      }
      if (prop in extraProps) {
        return true;
      }
      return prop in originalCtx2;
    },
    defineProperty(_originalCtx, prop, descriptor) {
      return Reflect.defineProperty(extraProps, prop, descriptor);
    },
    deleteProperty(_originalCtx, prop) {
      if (prop in extraProps) {
        return Reflect.deleteProperty(extraProps, prop);
      }
      deletedProps.add(prop);
      return true;
    },
    ownKeys(originalCtx2) {
      const extraKeys = Reflect.ownKeys(extraProps);
      const originalKeys = Reflect.ownKeys(originalCtx2);
      const deletedKeys = Array.from(deletedProps);
      const allKeys = new Set(extraKeys.concat(originalKeys.filter((keys) => !deletedKeys.includes(keys))));
      if (waitUntilPromises != null) {
        allKeys.add("waitUntil");
      }
      return Array.from(allKeys);
    },
    getOwnPropertyDescriptor(originalCtx2, prop) {
      if (prop in extraProps) {
        return Reflect.getOwnPropertyDescriptor(extraProps, prop);
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return Reflect.getOwnPropertyDescriptor(originalCtx2, prop);
    }
  });
}
function createDeferredPromise() {
  let resolveFn;
  let rejectFn;
  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return {
    promise,
    get resolve() {
      return resolveFn;
    },
    get reject() {
      return rejectFn;
    }
  };
}
function handleAbortSignalAndPromiseResponse(response$, abortSignal) {
  if (isPromise2(response$) && abortSignal) {
    const deferred$ = createDeferredPromise();
    abortSignal.addEventListener("abort", function abortSignalFetchErrorHandler() {
      deferred$.reject(abortSignal.reason);
    });
    response$.then(function fetchSuccessHandler(res) {
      deferred$.resolve(res);
    }).catch(function fetchErrorHandler(err) {
      deferred$.reject(err);
    });
    return deferred$.promise;
  }
  return response$;
}

class ServerAdapterRequestAbortSignal extends EventTarget {
  constructor() {
    super(...arguments);
    this.aborted = false;
    this._onabort = null;
  }
  throwIfAborted() {
    if (this.aborted) {
      throw this.reason;
    }
  }
  sendAbort() {
    this.reason = new DOMException("This operation was aborted", "AbortError");
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
}
var bunNodeCompatModeWarned = false;
var nodeRequestResponseMap = new WeakMap;

// node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI, signal }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    signal.addEventListener("abort", () => {
      readable.push(null);
    });
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      readable.push(Buffer.from(chunk));
      if (isLast) {
        readable.push(null);
      }
    });
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value) => {
    headers.append(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal) {
  for await (const chunk of fetchResponse.body) {
    if (signal.aborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse, signal) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  if (signal.aborted) {
    return;
  }
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal);
}

// node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  await Promise.allSettled(waitUntilPromises);
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill2,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onRequestHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise2(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise2(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise2(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {
    const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;
    nodeRequestResponseMap.set(nodeRequest, nodeResponse);
    return handleNodeRequest(nodeRequest, ...ctx);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    nodeRequestResponseMap.set(nodeRequest, serverResponse);
    let response$;
    try {
      response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise2(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, serverResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, serverResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const signal = new ServerAdapterRequestAbortSignal;
    const originalResEnd = res.end.bind(res);
    let resEnded = false;
    res.end = function(data) {
      resEnded = true;
      return originalResEnd(data);
    };
    const originalOnAborted = res.onAborted.bind(res);
    originalOnAborted(function() {
      signal.sendAbort();
    });
    res.onAborted = function(cb) {
      signal.addEventListener("abort", cb);
    };
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI,
      signal
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise2(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!signal.aborted && !resEnded) {
          return sendResponseToUwsOpts(res, response, signal);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
      });
    }
    try {
      if (!signal.aborted && !resEnded) {
        return sendResponseToUwsOpts(res, response$, signal);
      }
    } catch (err) {
      console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    let waitUntilPromises;
    const serverContext = filteredCtxParts.length > 1 ? completeAssign({}, ...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntilPromises = [] : undefined);
    const response$ = handleRequest(request, serverContext);
    if (waitUntilPromises?.length) {
      return handleWaitUntils(waitUntilPromises).then(() => response$);
    }
    return response$;
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || "href" in input) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        const request2 = new fetchAPI.Request(input, initOrCtx);
        const res$2 = handleRequestWithWaitUntil(request2, ...restOfCtx);
        return handleAbortSignalAndPromiseResponse(res$2, initOrCtx?.signal);
      }
      const request = new fetchAPI.Request(input);
      return handleRequestWithWaitUntil(request, ...maybeCtx);
    }
    const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);
    return handleAbortSignalAndPromiseResponse(res$, input._signal);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    handleNodeRequestAndResponse,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response2) {
  return function defaultErrorHandler(e) {
    if (e.details || e.status || e.headers || e.name === "HTTPError") {
      return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.message, {
        status: e.status,
        headers: e.headers || {}
      });
    }
    console.error(e);
    return createDefaultErrorResponse(ResponseCtor);
  };
}
var createDefaultErrorResponse = function(ResponseCtor) {
  if (ResponseCtor.error) {
    return ResponseCtor.error();
  }
  return new ResponseCtor(null, { status: 500 });
};
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise2(response$)) {
            return response$.catch((e) => errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response));
          }
          return response$;
        } catch (e) {
          return errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response);
        }
      });
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject2(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject2 = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
var import_graphql38 = __toESM(require_graphql2(), 1);
function assertMutationViaGet(method, document, operationName) {
  const operation = document ? import_graphql38.getOperationAST(document, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof import_graphql38.GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === undefined)
      return;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === undefined)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === undefined || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document = documentCache.get(strDocument);
      if (document) {
        setParsedDocument(document);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema2, documentAST, rules },
      setResult
    }) {
      if (schema2 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema2);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema2, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = "toJSON" in err && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions).length ? extensions : undefined
    });
  }
  return err;
};

// node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable3(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      try {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode("\r\n"));
          controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
          controller.enqueue(textEncoder.encode("\r\n"));
          const chunk = jsonStringifyResultWithoutInternals(value);
          const encodedChunk = textEncoder.encode(chunk);
          controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
          controller.enqueue(textEncoder.encode("\r\n"));
          controller.enqueue(textEncoder.encode("\r\n"));
          controller.enqueue(encodedChunk);
          controller.enqueue(textEncoder.encode("\r\n"));
          controller.enqueue(textEncoder.encode("---"));
        }
        if (done) {
          controller.enqueue(textEncoder.encode("--\r\n"));
          controller.close();
        }
      } catch (err) {
        controller.error(err);
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions?.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable3(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        try {
          const result2 = await iterator.next();
          if (result2.value != null) {
            controller.enqueue(textEncoder.encode(`event: next\n`));
            const chunk = jsonStringifyResultWithoutInternals(result2.value);
            controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
          }
          if (result2.done) {
            controller.enqueue(textEncoder.encode(`event: complete\n`));
            controller.enqueue(textEncoder.encode(`data:\n\n`));
            clearInterval(pingInterval);
            controller.close();
          }
        } catch (err) {
          controller.error(err);
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable3(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && !request.url.endsWith(`${args.graphqlEndpoint}/`) && url.pathname !== args.graphqlEndpoint && url.pathname !== `${args.graphqlEndpoint}/` && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// node_modules/graphql-yoga/esm/process-request.js
var import_graphql39 = __toESM(require_graphql2(), 1);
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document = enveloped.parse(params.query);
  const errors4 = enveloped.validate(enveloped.schema, document);
  if (errors4.length > 0) {
    return { errors: errors4 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = import_graphql39.getOperationAST(document, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error7, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error7)) {
    if (error7.originalError) {
      if (error7.originalError.name === "GraphQLError") {
        return error7;
      }
      const extensions = {
        ...error7.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error7.originalError.message,
          stack: error7.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error7.nodes,
        source: error7.source,
        positions: error7.positions,
        path: error7.path,
        extensions
      });
    }
    return error7;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error7 instanceof Error ? {
        message: error7.message,
        stack: error7.stack
      } : error7 : undefined
    }
  });
};

// node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  getEnveloped;
  logger;
  graphqlEndpoint;
  fetchAPI;
  plugins;
  onRequestParseHooks;
  onParamsHooks;
  onResultProcessHooks;
  maskedErrorsOpts;
  id;
  constructor(options) {
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger2 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger2 === "boolean" ? logger2 === true ? createLogger() : createLogger("silent") : typeof logger2 === "string" ? createLogger(logger2) : logger2;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error8, message) => {
        if (maskedErrorSet.has(error8)) {
          return error8;
        }
        const newError = maskErrorFn(error8, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error8) {
          this.logger.error(error8);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse: import_graphql40.parse,
        validate: import_graphql40.validate,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules: import_graphql40.specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error8, request) => {
        const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors4
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin({
              onSubscribe() {
                return {
                  onSubscribeError({ error: error8 }) {
                    if (isAbortError(error8)) {
                      throw error8;
                    }
                  }
                };
              }
            });
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request, batched }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const additionalContext = args[0]?.request === request ? {
          params
        } : {
          request,
          params
        };
        const initialContext = args[0] ? batched ? Object.assign({}, args[0], additionalContext) : Object.assign(args[0], additionalContext) : additionalContext;
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      if (isAsyncIterable3(result)) {
        const iterator = result[Symbol.asyncIterator]();
        result = mapAsyncIterator(iterator, (v) => v, (err) => {
          if (err.name === "AbortError") {
            this.logger.debug(`Request aborted`);
            throw err;
          }
          const errors4 = handleError(err, this.maskedErrorsOpts, this.logger);
          return {
            errors: errors4
          };
        });
      }
      return result;
    } catch (error8) {
      const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors4
      };
      return result;
    }
  }
  handle = async (request, serverContext) => {
    let url = new Proxy({}, {
      get: (_target, prop, _receiver) => {
        url = new this.fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    let requestParser;
    const onRequestParseDoneList = [];
    for (const onRequestParse of this.onRequestParseHooks) {
      const onRequestParseResult = await onRequestParse({
        request,
        url,
        requestParser,
        serverContext,
        setRequestParser(parser) {
          requestParser = parser;
        }
      });
      if (onRequestParseResult?.onRequestParseDone != null) {
        onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
      }
    }
    this.logger.debug(`Parsing request to extract GraphQL parameters`);
    if (!requestParser) {
      return new this.fetchAPI.Response(null, {
        status: 415,
        statusText: "Unsupported Media Type"
      });
    }
    let requestParserResult = await requestParser(request);
    for (const onRequestParseDone of onRequestParseDoneList) {
      await onRequestParseDone({
        requestParserResult,
        setRequestParserResult(newParams) {
          requestParserResult = newParams;
        }
      });
    }
    const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
      params,
      request,
      batched: true
    }, serverContext))) : this.getResultForParams({
      params: requestParserResult,
      request,
      batched: false
    }, serverContext));
    return processResult({
      request,
      result,
      fetchAPI: this.fetchAPI,
      onResultProcessHooks: this.onResultProcessHooks
    });
  };
}

// src/geometry.ts
function getMinMaxXY(polygon, tolerance = 0) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = (-Infinity);
  let maxY = (-Infinity);
  polygon.forEach(([x, y]) => {
    if (x < minX) {
      minX = x;
    }
    if (x > maxX) {
      maxX = x;
    }
    if (y < minY) {
      minY = y;
    }
    if (y > maxY) {
      maxY = y;
    }
  });
  minX -= tolerance;
  minY -= tolerance;
  maxX += tolerance;
  maxY += tolerance;
  return [minX, minY, maxX, maxY];
}
function doesPointIntersectLine([x, y], [[x1, y1], [x2, y2]]) {
  const isWithinYBounds = y < y1 !== y < y2;
  if (!isWithinYBounds) {
    return false;
  }
  const lineSlope = (x2 - x1) / (y2 - y1);
  const verticalDifference = y - y1;
  const lineIntersect = lineSlope * verticalDifference + x1;
  return x < lineIntersect;
}
function isPointInBoundingBox(polygon, point, tolerance = 0) {
  const [minX, minY, maxX, maxY] = getMinMaxXY(polygon, tolerance);
  return point[0] >= minX && point[0] <= maxX && point[1] >= minY && point[1] <= maxY;
}
function distance([x1, y1], [x2, y2]) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
function getUnitVector(line) {
  const [start, end] = line;
  const [dx, dy] = [end[0] - start[0], end[1] - start[1]];
  const magnitude = distance(start, end);
  return [dx / magnitude, dy / magnitude];
}
function getNormalVector(line) {
  const [dx, dy] = getUnitVector(line);
  return [dy, -dx];
}
function offsetPoint(point, normal, distance2) {
  const [dx, dy] = normal;
  return [point[0] + dx * distance2, point[1] + dy * distance2];
}
function inflatePolygon(polygon, distance2) {
  if (distance2 === 0) {
    return polygon;
  }
  const inflated = polygon.map((point, index) => {
    const previousPoint = polygon[(index - 1 + polygon.length) % polygon.length];
    const nextPoint = polygon[(index + 1) % polygon.length];
    const normalPrev = getNormalVector([previousPoint, point]);
    const normalNext = getNormalVector([point, nextPoint]);
    const normal = [
      (normalPrev[0] + normalNext[0]) / 2,
      (normalPrev[1] + normalNext[1]) / 2
    ];
    const magnitude = Math.sqrt(normal[0] ** 2 + normal[1] ** 2);
    const normalizedNormal = [
      normal[0] / magnitude,
      normal[1] / magnitude
    ];
    return offsetPoint(point, normalizedNormal, distance2);
  });
  return inflated;
}
function isPointInPolygon(polygon, point, tolerance = 0) {
  if (polygon.length < POLYGON_MINIMUM_POINTS) {
    return false;
  }
  const isInBoundingBox = isPointInBoundingBox(polygon, point, tolerance);
  if (!isInBoundingBox) {
    return false;
  }
  const inflatedPolygon = inflatePolygon(polygon, tolerance);
  const isInside = inflatedPolygon.reduce((wasLastInside, vertex, pointIndex, polygon2) => {
    const previousVertex = polygon2.at(pointIndex - 1);
    const intersectsLine = doesPointIntersectLine(point, [
      vertex,
      previousVertex
    ]);
    if (intersectsLine) {
      return !wasLastInside;
    }
    return wasLastInside;
  }, false);
  return isInside;
}
var POLYGON_MINIMUM_POINTS = 3;

// src/spc.ts
async function fetchForecast(day, type2) {
  const url = new URL(`/products/outlook/day${day}otlk_${type2}.lyr.geojson`, productBaseUrl);
  const response = await fetch(url);
  return response.json();
}
var findOutlookForLocation = function(location, forecast, getSignificant = false) {
  const locationPoint = [location.longitude, location.latitude];
  const features = forecast.features.filter((f) => getSignificant ? f.properties.LABEL === "SIGN" : f.properties.LABEL !== "SIGN").reverse();
  for (const feature of features) {
    const polygon = feature.geometry;
    if (polygon.type === "Polygon" && isPointInPolygon(polygon.coordinates[0], locationPoint)) {
      return feature.properties;
    }
    if (polygon.type === "MultiPolygon") {
      for (const coordinates of polygon.coordinates) {
        if (isPointInPolygon(coordinates[0], locationPoint)) {
          return feature.properties;
        }
      }
    }
  }
  return;
};
var isRiskCategory = function(value) {
  return typeof value === "string" && value in CategoryOutlook;
};
function getRiskCategory(value) {
  if (isRiskCategory(value)) {
    return CategoryOutlook[value];
  }
  return CategoryOutlook.NONE;
}
async function fetchForecastForPoint(day, type2, location) {
  const forecast = await fetchForecast(day, type2);
  const isCheckingForSignificant = type2 === ConvectiveForecastType.SignificantHail || type2 === ConvectiveForecastType.SignificantTornado || type2 === ConvectiveForecastType.SignificantWind;
  const properties = findOutlookForLocation(location, forecast, isCheckingForSignificant);
  return properties?.LABEL;
}
var ConvectiveForecastType;
(function(ConvectiveForecastType2) {
  ConvectiveForecastType2["Categorical"] = "cat";
  ConvectiveForecastType2["Tornado"] = "torn";
  ConvectiveForecastType2["SignificantTornado"] = "sigtorn";
  ConvectiveForecastType2["Hail"] = "hail";
  ConvectiveForecastType2["SignificantHail"] = "sighail";
  ConvectiveForecastType2["Wind"] = "wind";
  ConvectiveForecastType2["SignificantWind"] = "sigwind";
})(ConvectiveForecastType || (ConvectiveForecastType = {}));
var productBaseUrl = new URL("https://www.spc.noaa.gov");
var CategoryOutlook = {
  NONE: {
    id: "NONE",
    riskLevel: -1,
    name: "None",
    description: "No severe weather expected.",
    color: "#f0f0f0"
  },
  TSTM: {
    id: "TSTM",
    riskLevel: 0,
    name: "general thunderstorms",
    description: "General thunderstorms. <10% probability of severe.",
    color: "#c1e9c1"
  },
  MRGL: {
    id: "MRGL",
    riskLevel: 1,
    name: "marginal risk",
    description: "An area of severe storms of either limited organization and longevity, or very low coverage and marginal intensity.",
    color: "#66a366"
  },
  SLGT: {
    id: "SLGT",
    riskLevel: 2,
    name: "slight risk",
    description: "An area of severe storms expected to be more scattered in coverage and/or not as organized.",
    color: "#ffe066"
  },
  ENH: {
    id: "ENH",
    riskLevel: 3,
    name: "enhanced risk",
    description: "An area of severe storms with numerous severe storms possible with varying levels of intensity.",
    color: "#ffa366"
  },
  MDT: {
    id: "MDT",
    riskLevel: 4,
    name: "moderate risk",
    description: "An area where widespread severe weather with several tornadoes and/or numerous severe thunderstorms is likely, some of which should be intense. This risk is usually reserved for days with several supercells producing intense tornadoes and/or very large hail, or an intense squall line with widespread damaging winds.",
    color: "#e06666"
  },
  HIGH: {
    id: "HIGH",
    riskLevel: 5,
    name: "high risk",
    description: "An area where a severe weather outbreak is expected from either numerous intense and long-tracked tornadoes or a long-lived derecho-producing thunderstorm complex that produces hurricane-force wind gusts and widespread damage. This risk is reserved for when high confidence exists in widespread coverage of severe weather with embedded instances of extreme severe (i.e., violent tornadoes or very damaging convective wind events).",
    color: "#ee99ee"
  }
};

// src/schema.ts
var typeDefs = `
  type RiskCategory {
    """
    The identifier for the category from the SPC or "NONE" (e.g. "NONE", "MRGL", "SLGT", "ENH", "MDT", "HIGH").
    """
    id: ID!

    """
    The risk level of the category from -1 to 5.
    -1 is no risk, 0 is general thunderstorms, 1 is marginal risk, 2 is slight risk, 3 is enhanced risk, 4 is moderate risk, and 5 is high risk.
    """
    riskLevel: Int!

    """
    A readable name for the category.
    """
    name: String!

    """
    A description of the category.
    """
    description: String!

    """
    A suggested color for the category in hex format.
    """
    color: String!
  }

  input LocationInput {
    latitude: Float!
    longitude: Float!
  }

  type Location {
    latitude: Float!
    longitude: Float!
  }

  type ConvectiveOutlook {
    """
    The day of the forecast. 1 is today, 2 is tomorrow, 3 is the day after tomorrow.
    """
    day: Int!

    """
    Location of the forecast.
    """
    location: Location!

    """
    The categorical forecast for the day.
    """
    riskCategory: RiskCategory!
  }

  type DetailedConvectiveOutlook {
    """
    The day of the forecast. 1 is today, 2 is tomorrow, 3 is the day after tomorrow.
    """
    day: Int!

    """
    Location of the forecast.
    """
    location: Location!

    """
    The categorical forecast for the day.
    """
    riskCategory: RiskCategory!

    """
    Probability of a tornado occurring within 25 miles of the location.
    """
    tornadoProbability: Float!

    """
    If there is a >=10% probability of an EF2+ tornado within 25 miles of a point
    """
    hasSignificantTornadoRisk: Boolean!

    """
    Probability of hail >=1" in diameter occurring within 25 miles of the location.
    """
    hailProbability: Float!

    """
    If there is a >=10% probability of hail >=2" in diameter within 25 miles of a point
    """
    hasSignificantHailRisk: Boolean!

    """
    Probability of wind gusts >=58 mph occurring within 25 miles of the location.
    """
    windProbability: Float!

    """
    If there is a >=10% probability of wind gusts >=75 mph within 25 miles of a point
    """
    hasSignificantWindRisk: Boolean!
  }

  type ConvectiveOutlookDays {
    day1: DetailedConvectiveOutlook!
    day2: DetailedConvectiveOutlook!
    day3: ConvectiveOutlook!
  }

  type Query {
    convectiveOutlook(location: LocationInput!): ConvectiveOutlookDays!
  }
`;
var resolvers = {
  ConvectiveOutlook: {
    riskCategory: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.Categorical, parent.location);
      return getRiskCategory(forecast);
    }
  },
  DetailedConvectiveOutlook: {
    riskCategory: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.Categorical, parent.location);
      return getRiskCategory(forecast);
    },
    tornadoProbability: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.Tornado, parent.location);
      return Number(forecast) || 0;
    },
    hasSignificantTornadoRisk: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.SignificantTornado, parent.location);
      return forecast === "SIGN";
    },
    hailProbability: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.Hail, parent.location);
      return Number(forecast) || 0;
    },
    hasSignificantHailRisk: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.SignificantHail, parent.location);
      return forecast === "SIGN";
    },
    windProbability: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.Wind, parent.location);
      return Number(forecast) || 0;
    },
    hasSignificantWindRisk: async (parent) => {
      const forecast = await fetchForecastForPoint(parent.day, ConvectiveForecastType.SignificantWind, parent.location);
      return forecast === "SIGN";
    }
  },
  Query: {
    convectiveOutlook: (_, args) => {
      return {
        day1: {
          day: 1,
          location: args.location
        },
        day2: {
          day: 2,
          location: args.location
        },
        day3: {
          day: 3,
          location: args.location
        }
      };
    }
  }
};
var schema2 = createSchema({ typeDefs, resolvers });

// src/vercel-handler.ts
function GET(request) {
  return yoga.handleRequest(request, {});
}
function POST(request) {
  return yoga.handleRequest(request, {});
}
var yoga = createYoga({ schema: schema2 });
export {
  POST,
  GET
};
